var tipuesearch = {"pages":[{"title":"About Me!","text":"I have a PhD in Applied Physics from Caltech, with a specialization in Bioengineering. I did my doctoral work with Michael Elowitz I also like to program. I really like reading books. My CV is here.","tags":"pages","url":"https://michaeljflynn.net/pages/about-me.html","loc":"https://michaeljflynn.net/pages/about-me.html"},{"title":"Wavelets – part 1","text":"Note: imported from an earlier version of this blog. Sorry if anything is broken. If you enjoy this post, subscribe using the form to the left! I try to make new posts every weekend, though sometimes life gets in the way. This one took 3 months! Since my last post was on the fast Fourier transform I thought I would continue the theme of signal processing and write a post on wavelet analysis. However after looking over the subject for a couple weekends months I've decided to split this topic into several posts. This post is heavily informed by Gilbert Strang and Troung Nguyen's \"Wavelets and Filter Banks\" . To be honest, the book is hard to read, so I'll try to digest it the best I can for you here. Maybe I'm being hypocritical. I hope you can read this! Introduction Like the Fourier transform, the wavelet transform outputs a different representation of a set of data. The original data is usually represented as a series of measurements in time. For example, in an audio recording the data is a time series of voltages across the capacitor plate of a microphone. ## Time CapacitorVoltage ## 00:000000 0.1 ## 00:000001 0.13 ## 00:000002 0.15 ## ... ... The Fourier transform outputs a represention of the data as a combination of constant tones: ## Frequency Volume ## C-tone 0.1 ## D-tone 0.01 ## F-tone 0 ## ... ... Think of music. It might be more efficient to represent data as a set of tones than a series of millions of voltages. However, the Fourier Transform has a weird trait that it represents the signal as a series of constant tones that play the entire length of the recording . There is a math theorem that says any function can be fully represented in that way, but that's not how people think of music. Instead, people think of \"notes\" that happen at specific times in the recording, like sheet music. That is what the wavelet transform intends to represent. It would look something like this: ## Note Time Volume ## C-note 0 1 ## D-note 0 0 ## D-note 1 1 ## ... ... ... Representing certain types of data in this way is very efficient. Think of how sheet music is much easier to store than spreadsheets of billions of capacitor voltages. This is why many compression techniques for the web, like JPEG 2000 , use it to send data efficiently over the wire without losing the \"gist\" of the image. So how do we actually transform data into this representation? We need some sort of operation that will give us a compromise between the perfect time-resolution of original representation and the perfect frequency resolution of the Fourier transform. What if I told you there already exists an operation that has both high-resolution in frequency and high resolution in time? It's an elementary circuit in analog electronics, called the high-pass filter . The high pass filter takes a signal and filters out lower frequency components of that signal. An example output is illustrated below. I've drawn the results of a high-pass filter, labeled \"HPF\" and a complementary low-pass filter, labeled \"LPF\", with input coming from the right (same for both), and output going out to the left: HPF LPF Notice that the low pass output is \"smoothed out\" compared to the original signal. The spiky details are all in the output of the high-pass filter, i.e. those spikes are the high-frequency components. We could label the output of HPF with a label (\"C\") and the output would be the volume of that note at each moment in time. If this was a real music track and we wanted to compress and denoise, we might then filter out any entry of the data that is below a certain volume, and potentially get a good compression ratio. Unfortunately, since this diagram contains a stream of random noise, nothing really stands out. What about the other notes? Notice that there are still bumps in the output of the low-pass filter. What if we applied another high pass filter on its output, with a lower frequency bound? That would give us another \"band\" of frequencies we could represent with a \"note\". That's what the wavelet transform is: applying successive high-pass filters until we've completely separated the signal into frequency bands. And that's it. You understand wavelet analysis! (qualitatively). Quantitative description To get a quantative understanding of the wavelet transform, first let's build a model of the input signal. Let's say there is some signal with amplitude x ( t ) x(t) x ( t ) that starts at t = 0 t=0 t = 0 . In other words, x ( t ) = 0 x(t) = 0 x ( t ) = 0 or is undefined for t < 0 t<0 t < 0 . Let's also assume that x x x comes in equally spaced measurements, 1 unit of t t t apart, so we have x ( 0 ) , x ( 1 ) , x ( 2 ) , … x(0), x(1), x(2),\\dots x ( 0 ) , x ( 1 ) , x ( 2 ) , … as a stream of data and nothing else. Our input stream x ( t ) x(t) x ( t ) has a Fourier transform we'll call X ( ω ) X(\\omega) X ( ω ) . Note that since x x x has a time resolution of 1 entry per second, X X X is only meaningfully defined between − π -\\pi − π and π \\pi π . This can be seen be the definition of the Fourier transform: X ( ω ) = ∑ 0 ∞ x ( t ) e − i ω t X(\\omega) = \\sum_{0}&#94;{\\infty} x(t) e&#94;{-i \\omega t} X ( ω ) = 0 ∑ ∞ ​ x ( t ) e − iω t Extending ω \\omega ω past some range R R R : X ( ω + R ) = ∑ 0 ∞ x ( t ) e − i ( ω + R ) t = ∑ 0 ∞ x ( t ) e − i ω t e − i R t , X(\\omega + R) = \\sum_{0}&#94;{\\infty} x(t) e&#94;{-i (\\omega + R) t} = \\sum_{0}&#94;{\\infty} x(t) e&#94;{-i \\omega t} e&#94;{-i R t}, X ( ω + R ) = 0 ∑ ∞ ​ x ( t ) e − i ( ω + R ) t = 0 ∑ ∞ ​ x ( t ) e − iω t e − i Rt , we see that X ( ω ) = X ( ω + R ) X(\\omega) = X(\\omega + R) X ( ω ) = X ( ω + R ) whenever R t Rt Rt is an integer multiple of 2 π 2\\pi 2 π . Therefore, if t t t is an integer, X ( ω ) X(\\omega) X ( ω ) is redundant beyond R = 2 π R= 2\\pi R = 2 π . In general, if t = T t ′ t = Tt' t = T t ′ , where t ′ t' t ′ is a natural number and T T T is the sample spacing, X X X is redundant beyond R = 2 π / T R = 2\\pi/T R = 2 π / T . The smaller the sample spacing in time, the higher the frequency resolution. Define a filter as an operation on X ( ω ) X(\\omega) X ( ω ) that produces some output signal Y ( ω ) Y(\\omega) Y ( ω ) . This is usually some window function, H ( ω ) H(\\omega) H ( ω ) , so that: Y ( ω ) = H ( ω ) X ( ω ) . Y(\\omega) = H(\\omega) X(\\omega). Y ( ω ) = H ( ω ) X ( ω ) . One example of a window function is H ( ω ) = { 1 ∣ ω ∣ > π / 2 0 otherwise. H(\\omega) = \\begin{cases} 1 \\quad |\\omega| > \\pi/2 \\\\ 0 \\quad \\text{otherwise.} \\end{cases} H ( ω ) = { 1 ∣ ω ∣ > π /2 0 otherwise. ​ This window function flattens any frequencies less than π / 2 \\pi/2 π /2 , and lets them through otherwise. This is an example of a high-pass filter . It's not the one we will use though, because the Fourier transform of a discontinuous function has infinite components and we don't want that when we are implementing the filters in time-space. Let's look at the output and window functions in time-space. To do this, I'll just use the definition of the fourier transform: Y ( ω ) = H ( ω ) X ( ω ) ∑ t y ( t ) e − i ω t = ( ∑ k h ( k ) e − i ω k ) ( ∑ t ′ x ( t ′ ) e − i ω t ′ ) = ∑ t ′ ∑ k h ( k ) x ( t ′ ) e − i ω ( k + t ′ ) . \\begin{align*} Y(\\omega) &= H(\\omega) X(\\omega) \\\\ \\sum_t y(t) e&#94;{-i \\omega t} &= \\left ( \\sum_k h(k) e&#94;{-i \\omega k} \\right ) \\left ( \\\\ \\sum_{t'} x(t') e&#94;{-i \\omega t'} \\right ) \\\\ &= \\sum_{t'}\\sum_{k}h(k)x(t')e&#94;{-i \\omega (k + t')}. \\end{align*} Y ( ω ) t ∑ ​ y ( t ) e − iω t ​ = H ( ω ) X ( ω ) = ( k ∑ ​ h ( k ) e − iωk ) ( t ′ ∑ ​ x ( t ′ ) e − iω t ′ ) = t ′ ∑ ​ k ∑ ​ h ( k ) x ( t ′ ) e − iω ( k + t ′ ) . ​ So now on the left we have some expression with y ( t ) y(t) y ( t ) , and on the right we have an expression of h ( k ) h(k) h ( k ) and x ( t ) x(t) x ( t ) , with some exponential components. Notice that if we let t ′ = t − k t' = t - k t ′ = t − k , the exponential components become the same: ∑ t y ( t ) e − i ω t = ∑ t ∑ k h ( k ) x ( t − k ) e − i ω t . \\sum_t y(t) e&#94;{-i \\omega t} = \\sum_{t}\\sum_{k}h(k)x(t-k)e&#94;{-i \\omega t}. t ∑ ​ y ( t ) e − iω t = t ∑ ​ k ∑ ​ h ( k ) x ( t − k ) e − iω t . Therefore we can isolate a relationship between y ( t ) y(t) y ( t ) , h ( k ) h(k) h ( k ) , and x ( t ) x(t) x ( t ) : y ( t ) = ∑ k h ( k ) x ( t − k ) . y(t) = \\sum_{k}h(k)x(t-k). y ( t ) = k ∑ ​ h ( k ) x ( t − k ) . How can we interpret this? First, let's try an example. Since we can choose any filter that we want, let's try a filter where h ( 0 ) = 1 / 2 h(0) = 1/2 h ( 0 ) = 1/2 and h ( 1 ) = 1 / 2 h(1) = 1/2 h ( 1 ) = 1/2 , 0 otherwise. Then y ( t ) = 1 2 x ( t ) + 1 2 x ( t − 1 ) . y(t) = \\frac{1}{2}x(t) + \\frac{1}{2} x(t-1). y ( t ) = 2 1 ​ x ( t ) + 2 1 ​ x ( t − 1 ) . This is a 2-point moving average. Going back to the functional form of y ( t ) y(t) y ( t ) , you can see that the filter is just some rolling statistic on x x x . This concept struck me when I first realized it. Moving average and difference as low and high pass filters The 2-point moving average and difference, which I will call y l y_l y l ​ and y h y_h y h ​ , are very simple: y l ( t ) = 1 2 x ( t ) + 1 2 x ( t − 1 ) , and y_l(t) = \\frac{1}{2}x(t) + \\frac{1}{2} x(t-1),\\text{ and} y l ​ ( t ) = 2 1 ​ x ( t ) + 2 1 ​ x ( t − 1 ) , and y h ( t ) = 1 2 x ( t ) − 1 2 x ( t − 1 ) . y_h(t) = \\frac{1}{2}x(t) - \\frac{1}{2} x(t-1). y h ​ ( t ) = 2 1 ​ x ( t ) − 2 1 ​ x ( t − 1 ) . It turns out that they function as complementary filters. Moving average and difference in frequency space Let's see how these rolling statistics act in frequency space. Remember that we just need to take the Fourier transform on h h h to get to the function H H H that multiplies the frequency spectrum X X X . Let's do that. For h l ( k ) h_l(k) h l ​ ( k ) , the Fourier transform is H l ( ω ) = ∑ k h l ( k ) e − i ω k = h l ( 0 ) + h l ( 1 ) e − i ω = 1 2 ( 1 + e − i ω ) = 1 2 e − i ω / 2 ( e i ω / 2 + e − i ω 2 ) = e − i ω / 2 c o s ( ω / 2 ) . \\begin{align*} H_l(\\omega)& = \\sum_k h_l(k) e&#94;{-i \\omega k}\\\\ &= h_l(0) + h_l(1) e&#94;{-i \\omega} \\\\ &= \\frac{1}{2} (1 + e&#94;{-i \\omega}) \\\\ &= \\frac{1}{2}e&#94;{-i\\omega/2} (e&#94;{i \\omega/2} + e&#94;{-i \\omega 2}) \\\\ &= e&#94;{-i \\omega /2} cos(\\omega/2) . \\end{align*} H l ​ ( ω ) ​ = k ∑ ​ h l ​ ( k ) e − iωk = h l ​ ( 0 ) + h l ​ ( 1 ) e − iω = 2 1 ​ ( 1 + e − iω ) = 2 1 ​ e − iω /2 ( e iω /2 + e − iω 2 ) = e − iω /2 cos ( ω /2 ) . ​ To see what frequencies are being selected, we plot the magnitude ∣ H l ( ω ) ∣ = c o s ( ω / 2 ) |H_l(\\omega)| = cos(\\omega/2) ∣ H l ​ ( ω ) ∣ = cos ( ω /2 ) from − π -\\pi − π to π \\pi π : The magnitude is near 1 for frequencies ω \\omega ω near 0, and goes to zero near the limits, − π -\\pi − π and π \\pi π . We can do the same for h h ( k ) h_h(k) h h ​ ( k ) . The fourier transform is: H h ( ω ) = ∑ k h h ( k ) e − i ω k = h h ( 0 ) + h h ( 1 ) e − i ω = 1 2 ( 1 − e − i ω ) = 1 2 e − i ω / 2 ( e i ω / 2 − e − i ω 2 ) = e − i ω / 2 i s i n ( ω / 2 ) . \\begin{align*} H_h(\\omega)& = \\sum_k h_h(k) e&#94;{-i \\omega k}\\\\ &= h_h(0) + h_h(1) e&#94;{-i \\omega} \\\\ &= \\frac{1}{2} (1 - e&#94;{-i \\omega}) \\\\ &= \\frac{1}{2}e&#94;{-i\\omega/2} (e&#94;{i \\omega/2} - e&#94;{-i \\omega 2}) \\\\ &= e&#94;{-i \\omega /2} i sin(\\omega/2) . \\end{align*} H h ​ ( ω ) ​ = k ∑ ​ h h ​ ( k ) e − iωk = h h ​ ( 0 ) + h h ​ ( 1 ) e − iω = 2 1 ​ ( 1 − e − iω ) = 2 1 ​ e − iω /2 ( e iω /2 − e − iω 2 ) = e − iω /2 i s in ( ω /2 ) . ​ The plot of the maginitude H h ( ω ) H_h(\\omega) H h ​ ( ω ) is seems to be the complement of ∣ H l ( ω ) ∣ |H_l(\\omega)| ∣ H l ​ ( ω ) ∣ : This function goes to 1 at the endpoints − π -\\pi − π and π \\pi π , but goes to zero for frequencies near zero. Notice that neither of these filters are not even close to \"ideal filters\", i.e. they still let through some opposing frequency. That's okay, because this is just a simple example. It would be an interesting exercise to find different rolling statistics that act as much better filters. Probably could do so via reverse engineering a desired frequency spectrum. Complementarity These two filters complement each other. Notice that we can reconstruct the full signal by taking the sum or the difference of these two filter signals. y l ( t ) + y h ( t ) = 1 2 ( x ( t ) + x ( t − 1 ) + x ( t ) − x ( t − 1 ) ) = x ( t ) . y_l(t) + y_h(t) = \\frac{1}{2}\\left ( x(t) + x(t-1) + x(t) - x(t-1)\\right ) = x(t). y l ​ ( t ) + y h ​ ( t ) = 2 1 ​ ( x ( t ) + x ( t − 1 ) + x ( t ) − x ( t − 1 ) ) = x ( t ) . y l ( t ) − y h ( t ) = 1 2 ( x ( t ) + x ( t − 1 ) − x ( t ) + x ( t − 1 ) ) = x ( t − 1 ) . y_l(t) - y_h(t) = \\frac{1}{2}\\left ( x(t) + x(t-1) - x(t) + x(t-1) \\right )= x(t-1). y l ​ ( t ) − y h ​ ( t ) = 2 1 ​ ( x ( t ) + x ( t − 1 ) − x ( t ) + x ( t − 1 ) ) = x ( t − 1 ) . It is very important that the difference results in a series lagged by one time unit. This means that we can reconstruct the full signal using only the even members of both y l ( t ) y_l(t) y l ​ ( t ) and y h ( t ) y_h(t) y h ​ ( t ) . This means if we have N N N samples of x ( t ) x(t) x ( t ) , we only need N / 2 N/2 N /2 samples of each y l ( t ) y_l(t) y l ​ ( t ) to reconstruct the signal. Remember from the introduction how we planned to apply another high pass filter to the low pass filter output? Then we'll get two series with N / 4 N/4 N /4 samples. Applying to the low-pass output again will give us two with N / 8 N/8 N /8 samples, eventually getting down to 1 sample, at which point we'll stop. The complementarity of these two filters is important because it means our algorithm will terminate . Building the Wavelet pyramid So now we have a complementary low-pass filter and a high-pass filter. We have a plan to run a recursive algorithm: split a signal (blue) into a high-pass output (yellow) and low-pass output (red): = + downsample each sample so they only contain the even points, all we need to fully reproduce the symbol: = + and run the algorithm on the low-pass output, = + + until we are left with the ultimate low pass filter, the full average. = + + + For 8 input signal points, we have output 8 \"wavelet\" points, each level in the y-direction indicating an individual frequency band, each point in the x-direction is a measurement of the volume of that frequency band. Notice that there are fewer measurements the lower the frequency goes, they have less \"time-resolution\". Signals that vary less in time have lower time resolution. I hope these diagrams are useful for you to understand the concept, now I'm going to put them into matrix form. I'm skipping the pre-downsampling step, in the interest of space. I'm going to use the following notation: y h y_h y h ​ is the high-pass output after downsampling, y l y_l y l ​ is the low-pass output after downsampling, y l h y_{lh} y l h ​ is the output after the low-pass filter, downsampling, doing a high-pass filter on that, and downsampling, and so on for y l l y_{ll} y ll ​ , y l l h y_{llh} y ll h ​ , y l l l y_{lll} y lll ​ . Assuming that x x x is 8 samples long, the matrix equation is going to look something like this for the first step: [ y h ( 1 ) y h ( 3 ) y h ( 5 ) y h ( 7 ) y l ( 1 ) y l ( 3 ) y l ( 5 ) y l ( 7 ) ] = 1 2 [ − 1 1 0 0 0 0 0 0 0 0 − 1 1 0 0 0 0 0 0 0 0 − 1 1 0 0 0 0 0 0 0 0 − 1 1 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 1 ] [ x ( 0 ) x ( 1 ) x ( 2 ) x ( 3 ) x ( 4 ) x ( 5 ) x ( 6 ) x ( 7 ) ] \\begin{bmatrix} y_h(1) \\\\ y_h(3) \\\\ y_h(5) \\\\ y_h(7) \\\\ y_l(1) \\\\y_l(3) \\\\ y_l(5) \\\\ y_l(7) \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} -1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & -1 & 1 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & -1 & 1 \\\\ 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 \\\\ \\end{bmatrix} \\begin{bmatrix} x(0) \\\\ x(1) \\\\ x(2) \\\\ x(3) \\\\ x(4) \\\\ x(5) \\\\ x(6) \\\\ x(7) \\end{bmatrix} ​ y h ​ ( 1 ) y h ​ ( 3 ) y h ​ ( 5 ) y h ​ ( 7 ) y l ​ ( 1 ) y l ​ ( 3 ) y l ​ ( 5 ) y l ​ ( 7 ) ​ ​ = 2 1 ​ ​ − 1 0 0 0 1 0 0 0 ​ 1 0 0 0 1 0 0 0 ​ 0 − 1 0 0 0 1 0 0 ​ 0 1 0 0 0 1 0 0 ​ 0 0 − 1 0 0 0 1 0 ​ 0 0 1 0 0 0 1 0 ​ 0 0 0 − 1 0 0 0 1 ​ 0 0 0 1 0 0 0 1 ​ ​ ​ x ( 0 ) x ( 1 ) x ( 2 ) x ( 3 ) x ( 4 ) x ( 5 ) x ( 6 ) x ( 7 ) ​ ​ Now we have 4 high-pass points and 4 low-pass points, what will this matrix look like after doing a recursive pass on the low-pass? This problem looks the same, just using y l y_l y l ​ as the starting point and half as big: [ y l h ( 3 ) y l h ( 7 ) y l l ( 3 ) y l l ( 7 ) ] = 1 2 [ − 1 1 0 0 0 0 − 1 1 1 1 0 0 0 0 1 1 ] [ y l ( 1 ) y l ( 3 ) y l ( 5 ) y l ( 7 ) ] \\begin{bmatrix} y_{lh}(3) \\\\ y_{lh}(7) \\\\y_{ll}(3) \\\\ y_{ll}(7) \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} -1 & 1 & 0 & 0 \\\\ 0 & 0 & -1 & 1 \\\\ 1 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 1 \\end{bmatrix} \\begin{bmatrix} y_l(1) \\\\ y_l(3) \\\\y_l(5) \\\\ y_l(7) \\end{bmatrix} ​ y l h ​ ( 3 ) y l h ​ ( 7 ) y ll ​ ( 3 ) y ll ​ ( 7 ) ​ ​ = 2 1 ​ ​ − 1 0 1 0 ​ 1 0 1 0 ​ 0 − 1 0 1 ​ 0 1 0 1 ​ ​ ​ y l ​ ( 1 ) y l ​ ( 3 ) y l ​ ( 5 ) y l ​ ( 7 ) ​ ​ We can plug in the definition of y l y_l y l ​ to get y l h y_{lh} y l h ​ and y l l y_{ll} y ll ​ in terms of x x x . [ y l h ( 3 ) y l h ( 7 ) y l l ( 3 ) y l l ( 7 ) ] = 1 4 [ − 1 1 0 0 0 0 − 1 1 1 1 0 0 0 0 1 1 ] [ 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 1 ] [ x ( 0 ) x ( 1 ) x ( 2 ) x ( 3 ) x ( 4 ) x ( 5 ) x ( 6 ) x ( 7 ) ] = 1 4 [ − 1 − 1 1 1 0 0 0 0 0 0 0 0 − 1 − 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 ] [ x ( 0 ) x ( 1 ) x ( 2 ) x ( 3 ) x ( 4 ) x ( 5 ) x ( 6 ) x ( 7 ) ] \\begin{align*} \\begin{bmatrix} y_{lh}(3) \\\\ y_{lh}(7) \\\\y_{ll}(3) \\\\ y_{ll}(7) \\end{bmatrix} &= \\frac{1}{4} \\begin{bmatrix} -1 & 1 & 0 & 0 \\\\ 0 & 0 & -1 & 1 \\\\ 1 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 1 \\end{bmatrix} \\begin{bmatrix} 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 \\\\ \\end{bmatrix} \\begin{bmatrix} x(0) \\\\ x(1) \\\\ x(2) \\\\ x(3) \\\\ x(4) \\\\ x(5) \\\\ x(6) \\\\ x(7) \\end{bmatrix} \\\\ &= \\frac{1}{4} \\begin{bmatrix} -1 & -1 & 1 & 1 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & -1 & -1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\\\ \\end{bmatrix} \\begin{bmatrix} x(0) \\\\ x(1) \\\\ x(2) \\\\ x(3) \\\\ x(4) \\\\ x(5) \\\\ x(6) \\\\ x(7) \\end{bmatrix} \\\\ \\end{align*} ​ y l h ​ ( 3 ) y l h ​ ( 7 ) y ll ​ ( 3 ) y ll ​ ( 7 ) ​ ​ ​ = 4 1 ​ ​ − 1 0 1 0 ​ 1 0 1 0 ​ 0 − 1 0 1 ​ 0 1 0 1 ​ ​ ​ 1 0 0 0 ​ 1 0 0 0 ​ 0 1 0 0 ​ 0 1 0 0 ​ 0 0 1 0 ​ 0 0 1 0 ​ 0 0 0 1 ​ 0 0 0 1 ​ ​ ​ x ( 0 ) x ( 1 ) x ( 2 ) x ( 3 ) x ( 4 ) x ( 5 ) x ( 6 ) x ( 7 ) ​ ​ = 4 1 ​ ​ − 1 0 1 0 ​ − 1 0 1 0 ​ 1 0 1 0 ​ 1 0 1 0 ​ 0 − 1 0 1 ​ 0 − 1 0 1 ​ 0 1 0 1 ​ 0 1 0 1 ​ ​ ​ x ( 0 ) x ( 1 ) x ( 2 ) x ( 3 ) x ( 4 ) x ( 5 ) x ( 6 ) x ( 7 ) ​ ​ ​ You can see that that y l h ( 3 ) y_{lh}(3) y l h ​ ( 3 ) is x ( 3 ) + x ( 2 ) − x ( 1 ) − x ( 0 ) x(3) + x(2) - x(1) - x(0) x ( 3 ) + x ( 2 ) − x ( 1 ) − x ( 0 ) , it is a 4 point moving difference. It's like a stretched out version of the original high-pass filter. Likewise y l l y_{ll} y ll ​ is a 4-point moving difference, a stretched out version of the original low-pass filter. Let me recursively apply the algorithm one last time: [ y l l h ( 7 ) y l l l ( 7 ) ] = 1 2 [ − 1 1 1 1 ] [ y l l ( 3 ) y l l ( 7 ) ] [ y l l h ( 7 ) y l l l ( 7 ) ] = 1 8 [ − 1 1 1 1 ] [ 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 ] [ x ( 0 ) x ( 1 ) x ( 2 ) x ( 3 ) x ( 4 ) x ( 5 ) x ( 6 ) x ( 7 ) ] = 1 8 [ − 1 − 1 − 1 − 1 1 1 1 1 1 1 1 1 1 1 1 1 ] [ x ( 0 ) x ( 1 ) x ( 2 ) x ( 3 ) x ( 4 ) x ( 5 ) x ( 6 ) x ( 7 ) ] \\begin{align*} \\begin{bmatrix} y_{llh}(7) \\\\ y_{lll}(7) \\end{bmatrix} &= \\frac{1}{2} \\begin{bmatrix} -1 & 1 \\\\ 1 & 1 \\\\ \\end{bmatrix} \\begin{bmatrix} y_{ll}(3) \\\\ y_{ll}(7) \\end{bmatrix} \\\\ \\begin{bmatrix} y_{llh}(7) \\\\ y_{lll}(7) \\end{bmatrix} &= \\frac{1}{8} \\begin{bmatrix} -1 & 1 \\\\ 1 & 1 \\\\ \\end{bmatrix} \\begin{bmatrix} 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\end{bmatrix} \\begin{bmatrix} x(0) \\\\ x(1) \\\\ x(2) \\\\ x(3) \\\\ x(4) \\\\ x(5) \\\\ x(6) \\\\ x(7) \\end{bmatrix} \\\\ &= \\frac{1}{8} \\begin{bmatrix} -1 & -1 & -1 & -1 & 1 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\end{bmatrix} \\begin{bmatrix} x(0) \\\\ x(1) \\\\ x(2) \\\\ x(3) \\\\ x(4) \\\\ x(5) \\\\ x(6) \\\\ x(7) \\end{bmatrix} \\\\ \\end{align*} [ y ll h ​ ( 7 ) y lll ​ ( 7 ) ​ ] [ y ll h ​ ( 7 ) y lll ​ ( 7 ) ​ ] ​ = 2 1 ​ [ − 1 1 ​ 1 1 ​ ] [ y ll ​ ( 3 ) y ll ​ ( 7 ) ​ ] = 8 1 ​ [ − 1 1 ​ 1 1 ​ ] [ 1 0 ​ 1 0 ​ 1 0 ​ 1 0 ​ 0 1 ​ 0 1 ​ 0 1 ​ 0 1 ​ ] ​ x ( 0 ) x ( 1 ) x ( 2 ) x ( 3 ) x ( 4 ) x ( 5 ) x ( 6 ) x ( 7 ) ​ ​ = 8 1 ​ [ − 1 1 ​ − 1 1 ​ − 1 1 ​ − 1 1 ​ 1 1 ​ 1 1 ​ 1 1 ​ 1 1 ​ ] ​ x ( 0 ) x ( 1 ) x ( 2 ) x ( 3 ) x ( 4 ) x ( 5 ) x ( 6 ) x ( 7 ) ​ ​ ​ The third pass of the algorithm gives us an 8-point moving difference and average. The recursion stops here because you can no longer do any filters on one point of data. If we put all the high-pass results together in one matrix, it looks something like: [ y h ( 1 ) y h ( 3 ) y h ( 5 ) y h ( 7 ) y l h ( 3 ) y l h ( 7 ) y l l h ( 7 ) y l l l ( 7 ) ] = [ − h h 0 0 0 0 0 0 0 0 − h h 0 0 0 0 0 0 0 0 − h h 0 0 0 0 0 0 0 0 − h h − h 2 − h 2 h 2 h 2 0 0 0 0 0 0 0 0 − h 2 − h 2 h 2 h 2 − h 3 − h 3 − h 3 − h 3 h 3 h 3 h 3 h 3 h 3 h 3 h 3 h 3 h 3 h 3 h 3 h 3 ] [ x ( 0 ) x ( 1 ) x ( 2 ) x ( 3 ) x ( 4 ) x ( 5 ) x ( 6 ) x ( 7 ) ] \\begin{bmatrix} y_h(1) \\\\ y_h(3) \\\\ y_h(5) \\\\ y_h(7) \\\\ y_{lh}(3) \\\\y_{lh}(7) \\\\ y_{llh}(7) \\\\ y_{lll}(7) \\end{bmatrix} = \\begin{bmatrix} -h & h & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & -h & h & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & -h & h & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & -h & h \\\\ -h&#94;2 & -h&#94;2 & h&#94;2 & h&#94;2 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & -h&#94;2 & -h&#94;2 & h&#94;2 & h&#94;2 \\\\ -h&#94;3 & -h&#94;3 & -h&#94;3 & -h&#94;3 & h&#94;3 & h&#94;3 & h&#94;3 & h&#94;3 \\\\ h&#94;3 & h&#94;3 & h&#94;3 & h&#94;3 & h&#94;3 & h&#94;3 & h&#94;3 & h&#94;3 \\\\ \\end{bmatrix} \\begin{bmatrix} x(0) \\\\ x(1) \\\\ x(2) \\\\ x(3) \\\\ x(4) \\\\ x(5) \\\\ x(6) \\\\ x(7) \\end{bmatrix} ​ y h ​ ( 1 ) y h ​ ( 3 ) y h ​ ( 5 ) y h ​ ( 7 ) y l h ​ ( 3 ) y l h ​ ( 7 ) y ll h ​ ( 7 ) y lll ​ ( 7 ) ​ ​ = ​ − h 0 0 0 − h 2 0 − h 3 h 3 ​ h 0 0 0 − h 2 0 − h 3 h 3 ​ 0 − h 0 0 h 2 0 − h 3 h 3 ​ 0 h 0 0 h 2 0 − h 3 h 3 ​ 0 0 − h 0 0 − h 2 h 3 h 3 ​ 0 0 h 0 0 − h 2 h 3 h 3 ​ 0 0 0 − h 0 h 2 h 3 h 3 ​ 0 0 0 h 0 h 2 h 3 h 3 ​ ​ ​ x ( 0 ) x ( 1 ) x ( 2 ) x ( 3 ) x ( 4 ) x ( 5 ) x ( 6 ) x ( 7 ) ​ ​ where h = 1 2 h = \\frac{1}{2} h = 2 1 ​ . The matrix on the right is the normalized Haar matrix , corresponding to the Haar wavelet transform. The Haar wavelet transform was discovered in 1909 by Alfred Haar as just an example of an \"orthogonal system\" one could project a function onto. It wasn't considered a \"wavelet\" until around 75 years later, but it is. At each level of filter, we have filtered into some band of frequency which you can think of as a \"tone\". We could label y h = C y_h = C y h ​ = C , y l h = B y_{lh}=B y l h ​ = B , and y l l h = A y_{llh}= A y ll h ​ = A (and y l l l y_{lll} y lll ​ would just be some baseline background voltage). We also have some notion of \"when\" they happen in time, more for higher-frequency notes than for the lower-frequency notes. To complete the music analogy, our transform looks like this: [ C-note ( t = 1 ) C-note ( t = 3 ) C-note ( t = 5 ) C-note ( t = 7 ) B-note ( t = 3 ) B-note ( t = 7 ) A-note ( t = 7 ) Background ] = [ − h h 0 0 0 0 0 0 0 0 − h h 0 0 0 0 0 0 0 0 − h h 0 0 0 0 0 0 0 0 − h h − h 2 − h 2 h 2 h 2 0 0 0 0 0 0 0 0 − h 2 − h 2 h 2 h 2 − h 3 − h 3 − h 3 − h 3 h 3 h 3 h 3 h 3 h 3 h 3 h 3 h 3 h 3 h 3 h 3 h 3 ] [ Voltage(0) Voltage(1) Voltage(2) Voltage(3) Voltage(4) Voltage(5) Voltage(6) Voltage(7) ] \\begin{bmatrix} \\text{C-note}(t=1) \\\\ \\text{C-note}(t=3) \\\\ \\text{C-note}(t=5) \\\\ \\text{C-note}(t=7) \\\\ \\text{B-note}(t=3) \\\\\\text{B-note}(t=7) \\\\ \\text{A-note}(t=7) \\\\ \\text{Background} \\end{bmatrix} = \\begin{bmatrix} -h & h & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & -h & h & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & -h & h & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & -h & h \\\\ -h&#94;2 & -h&#94;2 & h&#94;2 & h&#94;2 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & -h&#94;2 & -h&#94;2 & h&#94;2 & h&#94;2 \\\\ -h&#94;3 & -h&#94;3 & -h&#94;3 & -h&#94;3 & h&#94;3 & h&#94;3 & h&#94;3 & h&#94;3 \\\\ h&#94;3 & h&#94;3 & h&#94;3 & h&#94;3 & h&#94;3 & h&#94;3 & h&#94;3 & h&#94;3 \\\\ \\end{bmatrix} \\begin{bmatrix} \\text{Voltage(0)} \\\\ \\text{Voltage(1)} \\\\ \\text{Voltage(2)} \\\\ \\text{Voltage(3)} \\\\ \\text{Voltage(4)} \\\\ \\text{Voltage(5)} \\\\ \\text{Voltage(6)} \\\\ \\text{Voltage(7)} \\end{bmatrix} ​ C-note ( t = 1 ) C-note ( t = 3 ) C-note ( t = 5 ) C-note ( t = 7 ) B-note ( t = 3 ) B-note ( t = 7 ) A-note ( t = 7 ) Background ​ ​ = ​ − h 0 0 0 − h 2 0 − h 3 h 3 ​ h 0 0 0 − h 2 0 − h 3 h 3 ​ 0 − h 0 0 h 2 0 − h 3 h 3 ​ 0 h 0 0 h 2 0 − h 3 h 3 ​ 0 0 − h 0 0 − h 2 h 3 h 3 ​ 0 0 h 0 0 − h 2 h 3 h 3 ​ 0 0 0 − h 0 h 2 h 3 h 3 ​ 0 0 0 h 0 h 2 h 3 h 3 ​ ​ ​ Voltage(0) Voltage(1) Voltage(2) Voltage(3) Voltage(4) Voltage(5) Voltage(6) Voltage(7) ​ ​ What is a wavelet? All this talk about wavelet transforms, and I haven't talked about wavelets very much. A wavelet is a class of functions that become the new basis of a coordinate transform, like the complex exponential in Fourier series. Each of the rows of the Haar matrix is a basis vector. So, in our case, a wavelet looks like the function: f ( x ) = { 1 0 < = x < 1 / 2 − 1 1 / 2 < = x < 1 0 otherwise , f(x) = \\begin{cases} 1 & 0<=x<1/2 \\\\ -1 & 1/2 <= x < 1 \\\\ 0 & \\text{otherwise} \\end{cases}, f ( x ) = ⎩ ⎨ ⎧ ​ 1 − 1 0 ​ 0 <= x < 1/2 1/2 <= x < 1 otherwise ​ , at different levels of scales and shift. When you have an incoming signal that is equal to a wavelet function, you should see the wavelet transform place the wavelet into an appropriate frequency bucket. The following is an animation of the wavelet transform in action, sorting output into different wavelet frequencies. The input is 256 measurements rolling in from the left into a buffer that goes out 256 entries to the left. This output is split into log ⁡ ( N ) − 1 = 7 \\log(N) - 1 = 7 lo g ( N ) − 1 = 7 wavelet scales using the filters we described above. You might notice that some of the lower-frequency filters update less often. That's because the wavelet transform is not \"shift-invariant\": if you shift the input signal forward by one unit of time, you don't get the output signal shifted forward by one unit of time, you actually get a different answer. Think of the signal where x ( t = 1 ) = 1 x(t=1)=1 x ( t = 1 ) = 1 , but 0 everywhere else. When I operate the moving difference algorithm on this, y h ( 1 ) = x ( 1 ) − x ( 0 ) = 1 − 0 = 1 y_h(1) = x(1) - x(0) = 1 - 0 = 1 y h ​ ( 1 ) = x ( 1 ) − x ( 0 ) = 1 − 0 = 1 . But let me shift the signal forward one, so that x ( t = 0 ) = 1 x(t=0) = 1 x ( t = 0 ) = 1 now. Now y h ( 1 ) = x ( 1 ) − x ( 0 ) = 0 − 1 = − 1 y_h(1)=x(1)-x(0)=0-1=-1 y h ​ ( 1 ) = x ( 1 ) − x ( 0 ) = 0 − 1 = − 1 . y h ( 1 ) y_h(1) y h ​ ( 1 ) has flipped over the y-axis. You might say \"hey, but now y h ( 0 ) = x ( 0 ) − x ( − 1 ) = 1 − 0 = 1 y_h(0) = x(0) - x(-1) = 1 - 0 = 1 y h ​ ( 0 ) = x ( 0 ) − x ( − 1 ) = 1 − 0 = 1 now\", but we don't have y h ( 0 ) y_h(0) y h ​ ( 0 ) because we downsampled . The only way to have shift invariance is to shift the signal one window length of the filter, in this case 2. This is actually a huge problem and I really don't like it. In any practical application, you aren't going to be able to align your filter windows perfectly with the incoming signal and so you are going to pick up wavelet frequencies that are misleading. You can see examples of this phenomena by unchecking the box \"Align Sent Wavelet Window\", wavelets get aliased at other frequencies. If anyone knows how to make a wavelet transform time-invariant or shift-invariant, I am super interested in that! Send Scale 0 Send Scale 1 Send Scale 2 Send Scale 3 Send Scale 4 Send Scale 5 Send Scale 6 Send Scale 7 Align Sent Wavlet Window Input Scale 0 Scale 1 Scale 2 Scale 3 Scale 4 Scale 5 Scale 6 Scale 7 One Comment Matias June 26, 2017 at 10:14 am Nice article! Please take a look at DTCWT/DTCWPT for shift-invariance: https://github.com/neurobiofisica/gymnotools/tree/master/dtcwpt https://github.com/hgomersall/dtcwt Comments are closed.","tags":"misc","url":"https://michaeljflynn.net/wavelets-part-1.html","loc":"https://michaeljflynn.net/wavelets-part-1.html"},{"title":"History and Derivation of the Fast Fourier Transform","text":"Note: imported from an earlier version of this blog. If you enjoy this post, subscribe using the form to the left! I try to make new posts every weekend, though sometimes life gets in the way (this one took 6 weekends). This is the second post in my series on great algorithms. My last post was on the Metropolis-Hastings algorithm . History and Motivation The Fourier transform is a fundamental operation in applied math. The original Fourier transform is attributed to Joseph Fourier , a French mathematician and physicist, for solving partial differential equations involved in the transfer of heat [1]. Since then, the revelation that any function can be approximated by a series of sines and cosines has exploded far beyond the original application. The technique is used in applications from digital signal processing to medical imaging to detecting nuclear tests. Until the FFT, all applications used an algorithm that summed N N N terms for each of N N N output terms, and therefore had an asymptotic runtime of O ( N 2 ) O(N&#94;2) O ( N 2 ) . The O ( N log ⁡ N ) O(N\\log N) O ( N lo g N ) algorithm was first presented in a complete, packaged form in the 1965 paper by John Tukey and James Cooley : \"An algorithm for the machine calculation of complex fourier series\" [2]. There is evidence that the FFT had been discovered before. Gauss used the algorithm in the early 1800s to interpolate the trajectory of the asteroid Pallas but never published his results (aymptotic runtime matters when you're doing all the computation by hand). The Ex Libris blog gives an interesting analysis of Gauss's approach here . Others claim to have discovered the fundamental principle behind the FFT first, but no one got it in a form that made users realize they could perform their O ( N 2 ) O(N&#94;2) O ( N 2 ) computations in O ( N log ⁡ N ) O(N\\log N) O ( N lo g N ) until Tukey and Cooley and for that they deserve credit. The motivation behind the development of the FFT was not academic. This was the case for many algorithmic improvements of the 50's and 60's. In a time where business-scale mainframe computers like the IBM System/360 only had processing speeds of 35 kilohertz and memory sizes of 512 kilobytes, optimizing algorithms for memory and time performance had material economic benefits for companies. For the FFT there were national security reasons as well. James Cooley gives an interesting account of his development of the algorithm in a 1988 issue of Mikrochmica Acta : \"The Re-Discovery of the Fast Fourier Transform Algorithm\" [3]. The way he tells it, the (hydrogen-bomb) physicist Richard Garwin had a huge part in putting the effort together, for Cold-War purposes: I was working on a research project of my own when Richard Garwin came to the computing center of the laboratory with some notes he made while with John Tukey at a meeting of President Kennedy's Scientific Advisory Committee, of which they were both members. John Tukey showed that if N N N , is a composite, N = a b N = ab N = ab , then the Fourier series can be expressed as an a-term series of subseries of b terms each. If one were computing all values of the series, this would reduce the number of operations from N 2 N&#94;2 N 2 to N ( a + b ) N(a+ b) N ( a + b ) . Tukey also said that if this were iterated, the number of operations would be proportional to N log ⁡ ( N ) N\\log (N) N lo g ( N ) instead of N 2 N&#94;2 N 2 . Garwin knew that this was a very important calculation and he wanted to have this idea developed and applied. Garwin described his problem of determining the periodicities of the spin orientations in a 3-D crystal of He$&#94;3$. Later, I found out that he was far more interested in improving the ability to do remote seismic monitoring of nuclear explosions since the Russians would not agree to inspections within their borders thereby hindering efforts at obtaining a nuclear test ban treaty. He also saw a need for the capability of long range acoustical detection of submarines. Like many others, I did not see the significance in this improvement and gave the job a little less priority than my own research. However, I was told of Garwin's reputation and, prodded by his occasional telephone calls (some of them to my manager), I produced a 3-dimensional FFT program. I put some effort into designing the algorithm so as to save storage and addressing by over-writing data and I spent some time working out a 3-dimensional indexing scheme that was combined with the indexing within the algorithm. Garwin publicized the program at first through his many personal contacts, producing a small but increasing stream of requests for copies of it. This is not to say that Garwin came up with the idea or wrote the code or paper, but his presence here is indisputable. I am impressed that Garwin was able to pose a dummy physics problem for Cooley to solve that he could then use to detect nuclear tests and track nuclear submarines – but that is the immense power of the FFT. Cooley's article has lots of historical tidbits in it, including notes about the computational limits of the day. One detail is the \"record\" Fourier transform on a dataset with 2048 samples: Another member of our department, Lee Alsop, who was a geophysicist and adjunct professor at the Lamont Geophysical Laboratory of Columbia University decided to try the new algorithm on a record of 2048 samples of a strain seismograph of the Rat Island earthquake. Another is an example of computation that was still infeasible, even with the algorithmic speedups. When approached by a colleague with spectrum data to analyze he recounts: One extraordinary thing about this was that a single record of data was about 512 000 points and all values of the spectrum were needed. This was beyond the capacity of the high speed memory of existing machines. He also mentions that the FFT does give a theoretical speedup by a factor of 12,800 in this case. Finally the collaboration with Tukey was very limited (as well as the editing): Thus, the paper made only one round trip between me and Tukey and our only collaboration was in a few telephone conversations. Perhaps that explains why it is not very easy to read… Since then, there have been too many applications of the FFT to count. The algorithm goes so far as to be one of the fundamental operations in gate-based quantum computing . Therefore, it's probably worth a look. Introduction The idea is to take advantage of symmetries in the complex exponential to \"factor\" the problem into several smaller problems recursively, yeilding standard \"divide and conquer\" speedups. While the algorithm has been generalized to work for any composite number of datapoints, the presentation is easiest when the number of points is a power of 2, so that is a fundamental assumption I will make throughout this post. I'm going to assume that readers are familiar with the Fourier series and it's generalization, the Fourier transform at a superficial level. To review, you can approximate any function over an interval of length L L L with sines and cosines with period equal to L L L : f ( x ) = 1 2 a 0 + ∑ n = 1 ∞ a n sin ⁡ ( 2 π L n x ) + ∑ n = 1 ∞ b n cos ⁡ ( 2 π L n x ) . f(x) = \\frac{1}{2} a_0 + \\sum_{n = 1}&#94;{\\infty} a_n \\sin \\left (\\frac{2\\pi}{L}nx \\right ) + \\sum_{n=1}&#94;{\\infty} b_n \\cos \\left (\\frac{2\\pi}{L}nx \\right ). f ( x ) = 2 1 ​ a 0 ​ + n = 1 ∑ ∞ ​ a n ​ sin ( L 2 π ​ n x ) + n = 1 ∑ ∞ ​ b n ​ cos ( L 2 π ​ n x ) . Using the identities e i θ = cos ⁡ θ + i sin ⁡ θ e&#94;{i\\theta} = \\cos\\theta + i\\sin\\theta e i θ = cos θ + i sin θ , sin ⁡ θ = i 2 ( e i θ + e − i θ ) \\sin\\theta = \\frac{i}{2}(e&#94;{i\\theta} + e&#94;{-i\\theta}) sin θ = 2 i ​ ( e i θ + e − i θ ) , and cos ⁡ θ = 1 2 ( e i θ – e − i θ ) \\cos\\theta = \\frac{1}{2}(e&#94;{i\\theta} – e&#94;{-i\\theta}) cos θ = 2 1 ​ ( e i θ – e − i θ ) , these terms can be represented as complex exponentials: f ( x ) = 1 2 a 0 + ∑ n = 1 ∞ a n sin ⁡ ( 2 π L n x ) + ∑ n = 1 ∞ b n cos ⁡ ( 2 π L n x ) = 1 2 a 0 + 1 2 ∑ n = 1 ∞ i a n ( e 2 π i n x / L – e − 2 π i n x / L ) + 1 2 ∑ n = 1 ∞ b n ( e 2 π i n x / L + e − 2 π i n x / L ) = 1 2 a 0 e 2 π i 0 x / L + 1 2 ∑ n = 1 ∞ ( b n + i a n ) e 2 π i n x / L + 1 2 ∑ n = 1 ∞ ( b n – i a n ) e − 2 π i n x / L \\begin{align*} f(x) =& \\frac{1}{2} a_0 + \\sum_{n = 1}&#94;{\\infty} a_n \\sin \\left (\\frac{2\\pi}{L}nx \\right ) + \\sum_{n=1}&#94;{\\infty} b_n \\cos \\left (\\frac{2\\pi}{L}nx \\right ) \\\\ =& \\frac{1}{2} a_0 + \\frac{1}{2}\\sum_{n = 1}&#94;{\\infty} ia_n (e&#94;{2\\pi i n x / L} – e&#94;{-2\\pi i n x / L}) + \\frac{1}{2}\\sum_{n=1}&#94;{\\infty} b_n (e&#94;{2\\pi i n x / L} + e&#94;{-2\\pi i n x / L}) \\\\ =& \\frac{1}{2} a_0 e&#94;{2\\pi i 0 x / L} + \\frac{1}{2}\\sum_{n = 1}&#94;{\\infty} (b_n + ia_n) e&#94;{2\\pi i n x / L} + \\frac{1}{2}\\sum_{n=1}&#94;{\\infty} (b_n – i a_n) e&#94;{-2\\pi i n x / L} \\end{align*} f ( x ) = = = ​ 2 1 ​ a 0 ​ + n = 1 ∑ ∞ ​ a n ​ sin ( L 2 π ​ n x ) + n = 1 ∑ ∞ ​ b n ​ cos ( L 2 π ​ n x ) 2 1 ​ a 0 ​ + 2 1 ​ n = 1 ∑ ∞ ​ i a n ​ ( e 2 πin x / L – e − 2 πin x / L ) + 2 1 ​ n = 1 ∑ ∞ ​ b n ​ ( e 2 πin x / L + e − 2 πin x / L ) 2 1 ​ a 0 ​ e 2 πi 0 x / L + 2 1 ​ n = 1 ∑ ∞ ​ ( b n ​ + i a n ​ ) e 2 πin x / L + 2 1 ​ n = 1 ∑ ∞ ​ ( b n ​ – i a n ​ ) e − 2 πin x / L ​ Notice that that if we define c 0 = 1 2 a 0 c_0 = \\frac{1}{2} a_0 c 0 ​ = 2 1 ​ a 0 ​ , c n = 1 2 ( b n + sign ( n ) i a n ) c_n = \\frac{1}{2} (b_n + \\text{sign}(n) i a_n) c n ​ = 2 1 ​ ( b n ​ + sign ( n ) i a n ​ ) , we can simplify the above to the final form: f ( x ) = ∑ n = − ∞ ∞ c n e 2 π i n x / L . f(x) = \\sum_{n = -\\infty}&#94;{\\infty} c_n e&#94;{2\\pi i n x / L}. f ( x ) = n = − ∞ ∑ ∞ ​ c n ​ e 2 πin x / L . The coefficients can be found by taking advantage of an indentity of the complex exponential: it integrates to zero over one full period, i.e. ∫ 0 L e 2 π i ( m − n ) x / L = L \\int_0&#94;L e&#94;{2\\pi i (m-n) x / L} = L ∫ 0 L ​ e 2 πi ( m − n ) x / L = L if m = n m=n m = n and 0 0 0 of m ≠ n m \\neq n m  = n . This can be used to isolate c m c_m c m ​ : ∫ 0 L f ( x ) e − 2 π i m x d x = ∑ n = − ∞ ∞ c n ∫ 0 L e 2 π i n x / L e 2 π i m x / L d x = ∑ n = − ∞ ∞ c n ∫ 0 L e 2 π i ( n – m ) x / L = L c m \\int_0&#94;L f(x) e&#94;{-2 \\pi i m x} dx = \\sum_{n = -\\infty}&#94;{\\infty} c_n \\int_0&#94;L e&#94;{2 \\pi i n x / L} e&#94;{2 \\pi i m x / L}dx = \\sum_{n = -\\infty}&#94;{\\infty} c_n \\int_0&#94;L e&#94;{2 \\pi i (n – m) x / L} = Lc_m ∫ 0 L ​ f ( x ) e − 2 πim x d x = n = − ∞ ∑ ∞ ​ c n ​ ∫ 0 L ​ e 2 πin x / L e 2 πim x / L d x = n = − ∞ ∑ ∞ ​ c n ​ ∫ 0 L ​ e 2 πi ( n – m ) x / L = L c m ​ Therefore c m = 1 L ∫ 0 L f ( x ) e − 2 π i m x / L d x . c_m = \\frac{1}{L} \\int_0&#94;L f(x) e&#94;{-2\\pi imx/L} dx. c m ​ = L 1 ​ ∫ 0 L ​ f ( x ) e − 2 πim x / L d x . This is the basis of the complex Fourier series. The output of the Fourier transform is the set of c m c_m c m ​ ‘s. The Discrete Fourier Series In practice, we cannot compute each of the infinite c m c_m c m ​ , and it turns out we do not have enough information to do so. In almost all applications, we do not have f ( x ) f(x) f ( x ) , rather we have N N N evenly-spaced samples from f ( x ) f(x) f ( x ) stored in a computer. Unfortunately, this limits how far out in frequency space we can get. For example, consider what happens when analyzing the coefficient of the frequency N N N . The function goes through one full period before it reaches the next point, so you are effectively applying a constant displacement to each point, the same effect as the frequency n = 0 n=0 n = 0 . In general, each of the points will be effected in the same way for frequency n n n as the frequency n + N n +N n + N , and we get no new information from analyzing beyond n = N − 1 n = N-1 n = N − 1 . Therefore, in our output we are only looking for frequencies 0 0 0 through N − 1 N-1 N − 1 . If we have N N N points, we are looking for N N N frequencies, each computed via the discrete integral: c ( n ) = 1 N ∑ x = 0 N − 1 f ( x ) e − 2 π i n x / N c(n) = \\frac{1}{N} \\sum_{x = 0}&#94;{N-1} f(x) e&#94;{-2\\pi i n x /N} c ( n ) = N 1 ​ x = 0 ∑ N − 1 ​ f ( x ) e − 2 πin x / N This is effectively computing the integral with a rectangular approximation 1 L ∫ 0 L f ( x ) e − 2 π i n x / L d x ≈ 1 L L N ∑ x ' = 0 N − 1 f ( x ' ) e − 2 π i n x ' / N . \\frac{1}{L} \\int_0&#94;L f(x) e&#94;{-2\\pi i nx/L} dx \\approx \\frac{1}{L} \\frac{L}{N} \\sum_{x'=0}&#94;{N-1} f(x') e&#94;{-2\\pi i n x' / N}. L 1 ​ ∫ 0 L ​ f ( x ) e − 2 πin x / L d x ≈ L 1 ​ N L ​ ∑ x ' = 0 N − 1 ​ f ( x ' ) e − 2 πin x '/ N . where x = L / N x ' x = L/N x' x = L / N x ' . From here, I'm going to drop the normalizing term 1 N \\frac{1}{N} N 1 ​ and assume it will be applied at the end. Also, it's much easier from this point to look at the Fourier transform using a picture. We can imagine the discrete Fourier transform as a circuit taking in the N N N samples as input and giving the N N N Fourier coefficients as output. This is depicted below, with the inputs f ( x ) f(x) f ( x ) coming in from the left, and the outputs c ( n ) c(n) c ( n ) coming out to the right. Notice that each of the N N N terms of the output needs to compute a sum of N N N terms, and therefore the runtime of this circuit is O ( N 2 ) O(N&#94;2) O ( N 2 ) . f ( 0 ) → → 1 8 ∑ x = 0 7 f ( x ) = c ( 0 ) f ( 1 ) → → 1 8 ∑ x = 0 7 f ( x ) e − 2 π i x / 8 = c ( 1 ) f ( 2 ) → → 1 8 ∑ x = 0 7 f ( x ) e − 2 π i 2 x / 8 = c ( 2 ) f ( 3 ) → Discrete Fouirer Transform → 1 8 ∑ x = 0 7 f ( x ) e − 2 π i 3 x / 8 = c ( 3 ) f ( 4 ) → → 1 8 ∑ x = 0 7 f ( x ) e − 2 π i 4 x / 8 = c ( 4 ) f ( 5 ) → → 1 8 ∑ x = 0 7 f ( x ) e − 2 π i 5 x / 8 = c ( 5 ) f ( 6 ) → → 1 8 ∑ x = 0 7 f ( x ) e − 2 π i 6 x / 8 = c ( 6 ) f ( 7 ) → → 1 8 ∑ x = 0 7 f ( x ) e − 2 π i 7 x / 8 = c ( 7 ) \\begin{array}{ll|ccc|llll} \\hline f(0) & \\rightarrow & & & & \\rightarrow & \\frac{1}{8} \\sum\\limits_{x = 0}&#94;{7} f(x) & = & c(0)\\\\ f(1) & \\rightarrow & & & & \\rightarrow & \\frac{1}{8} \\sum\\limits_{x = 0}&#94;{7} f(x) e&#94;{-2\\pi i x /8} & =& c(1) \\\\ f(2) & \\rightarrow & & & & \\rightarrow & \\frac{1}{8} \\sum\\limits_{x = 0}&#94;{7} f(x) e&#94;{-2\\pi i 2 x /8} & =& c(2)\\\\ f(3) & \\rightarrow & & \\text{Discrete Fouirer Transform} & & \\rightarrow & \\frac{1}{8} \\sum\\limits_{x = 0}&#94;{7} f(x) e&#94;{-2\\pi i 3 x /8} & =& c(3) \\\\ f(4) & \\rightarrow & & & & \\rightarrow & \\frac{1}{8} \\sum\\limits_{x = 0}&#94;{7} f(x) e&#94;{-2\\pi i 4 x /8} & =& c(4)\\\\ f(5) & \\rightarrow & & & & \\rightarrow & \\frac{1}{8} \\sum\\limits_{x = 0}&#94;{7} f(x) e&#94;{-2\\pi i 5 x /8} & =& c(5)\\\\ f(6) & \\rightarrow & & & & \\rightarrow & \\frac{1}{8} \\sum\\limits_{x = 0}&#94;{7} f(x) e&#94;{-2\\pi i 6 x /8} & =& c(6)\\\\ f(7) & \\rightarrow & & & & \\rightarrow & \\frac{1}{8} \\sum\\limits_{x = 0}&#94;{7} f(x) e&#94;{-2\\pi i 7 x /8} & =& c(7)\\\\ \\hline \\end{array} f ( 0 ) f ( 1 ) f ( 2 ) f ( 3 ) f ( 4 ) f ( 5 ) f ( 6 ) f ( 7 ) ​ → → → → → → → → ​ ​ Discrete Fouirer Transform ​ ​ → → → → → → → → ​ 8 1 ​ x = 0 ∑ 7 ​ f ( x ) 8 1 ​ x = 0 ∑ 7 ​ f ( x ) e − 2 πi x /8 8 1 ​ x = 0 ∑ 7 ​ f ( x ) e − 2 πi 2 x /8 8 1 ​ x = 0 ∑ 7 ​ f ( x ) e − 2 πi 3 x /8 8 1 ​ x = 0 ∑ 7 ​ f ( x ) e − 2 πi 4 x /8 8 1 ​ x = 0 ∑ 7 ​ f ( x ) e − 2 πi 5 x /8 8 1 ​ x = 0 ∑ 7 ​ f ( x ) e − 2 πi 6 x /8 8 1 ​ x = 0 ∑ 7 ​ f ( x ) e − 2 πi 7 x /8 ​ = = = = = = = = ​ c ( 0 ) c ( 1 ) c ( 2 ) c ( 3 ) c ( 4 ) c ( 5 ) c ( 6 ) c ( 7 ) ​ ​ However, there seems to be redundancy here. Each of these terms is a sum of the f ( x ) f(x) f ( x ) terms, each with a complex exponential slapped on, but the complex exponential is periodic . Take c ( 0 ) c(0) c ( 0 ) and c ( 4 ) c(4) c ( 4 ) for example. c ( 0 ) = ∑ x = 0 7 f ( x ) . c(0) = \\sum_{x = 0}&#94;7 f(x). c ( 0 ) = x = 0 ∑ 7 ​ f ( x ) . c ( n ) = ∑ x = 0 7 f ( x ) e − 2 π i 4 x / 8 = ∑ x = 0 7 f ( x ) e − π i x c(n) = \\sum_{x = 0}&#94;7 f(x) e&#94;{-2\\pi i 4 x /8} = \\sum_{x = 0}&#94;7 f(x) e&#94;{-\\pi i x} c ( n ) = x = 0 ∑ 7 ​ f ( x ) e − 2 πi 4 x /8 = x = 0 ∑ 7 ​ f ( x ) e − πi x They are the same sum, except each term of c ( 4 ) c(4) c ( 4 ) has an extra term of e − π i x e&#94;{-\\pi i x} e − πi x slapped on. This term is going to be equal to 1 for even numbers of x x x and equal to − 1 -1 − 1 for odd number of x x x . This behavior is independant of n n n : if we pair up any Fourier coefficient with the coefficient that is N / 2 N/2 N /2 indices up from it (for example 1 and 5, 2 and 6, and 3 and 7), we will find the same relationship since e − 2 π i ( n + N / 2 ) x / N = e − 2 π i n x / N e π i x . e&#94;{-2\\pi i (n + N/2) x / N} = e&#94;{-2\\pi i n x / N} e&#94;{\\pi i x}. e − 2 πi ( n + N /2 ) x / N = e − 2 πin x / N e πi x . This suggests a strategy: there are really only N N N terms to work out between c ( n ) c(n) c ( n ) and c ( n + N / 2 ) c(n + N/2) c ( n + N /2 ) (instead of 2 N 2N 2 N ), we just need to remember to slap a -1 onto the odd terms for c ( n + N / 2 ) c(n+N/2) c ( n + N /2 ) . This leads us to the next symmetry we can exploit. We can divide these two sums into 2 sums of the form \"full sum\" = \"even terms\" + \"odd terms\". I will do this out for the N = 8 N=8 N = 8 case but you will see how it can easily generalize. For c ( n ) c(n) c ( n ) this looks like: c ( n ) = ∑ x = 0 7 f ( x ) e − 2 π i n x / 8 = ∑ x = 0 4 f ( 2 x ) e − 2 π i n ( 2 x ) / 8 ⏞ even terms + ∑ x = 0 4 f ( 2 x + 1 ) e − 2 π i n ( 2 x + 1 ) / 8 ⏞ odd terms = ∑ x = 0 4 f ( 2 x ) e − 2 π i n x / 4 + ∑ x = 0 4 f ( 2 x + 1 ) e − 2 π i n x / 4 e − π i n / 4 . \\begin{align*} c(n) = \\sum\\limits_{x = 0}&#94;{7} f(x) e&#94;{-2\\pi i n x /8} &= \\overbrace{\\sum\\limits_{x = 0}&#94;{4} f(2x) e&#94;{-2\\pi i n (2x) /8}}&#94;{\\text{even terms}} + \\overbrace{\\sum\\limits_{x = 0}&#94;{4} f(2x + 1) e&#94;{-2\\pi i n (2x+1) /8}}&#94;{\\text{odd terms}} \\\\ &= \\sum\\limits_{x = 0}&#94;{4} f(2x) e&#94;{-2\\pi i n x /4} + \\sum\\limits_{x = 0}&#94;{4} f(2x + 1) e&#94;{-2\\pi i n x /4} e&#94;{-\\pi i n /4}. \\end{align*} c ( n ) = x = 0 ∑ 7 ​ f ( x ) e − 2 πin x /8 ​ = x = 0 ∑ 4 ​ f ( 2 x ) e − 2 πin ( 2 x ) /8 ​ even terms ​ + x = 0 ∑ 4 ​ f ( 2 x + 1 ) e − 2 πin ( 2 x + 1 ) /8 ​ odd terms ​ = x = 0 ∑ 4 ​ f ( 2 x ) e − 2 πin x /4 + x = 0 ∑ 4 ​ f ( 2 x + 1 ) e − 2 πin x /4 e − πin /4 . ​ For c ( n + N / 2 ) c(n + N/2) c ( n + N /2 ) this looks like: c ( n + N / 2 ) = ∑ x = 0 7 f ( x ) e − 2 π i n x / 8 e − π i x = ∑ x = 0 4 f ( 2 x ) e − 2 π i n ( 2 x ) / 8 ⏞ even terms – ∑ x = 0 4 f ( 2 x + 1 ) e − 2 π i n ( 2 x + 1 ) / 8 ⏞ odd terms = ∑ x = 0 4 f ( 2 x ) e − 2 π i n x / 4 – ∑ x = 0 4 f ( 2 x + 1 ) e − 2 π i n x / 4 e − π i n / 4 . \\begin{align*} c(n + N/2) = \\sum\\limits_{x = 0}&#94;{7} f(x) e&#94;{-2\\pi i n x /8}e&#94;{-\\pi i x} &= \\overbrace{\\sum\\limits_{x = 0}&#94;{4} f(2x) e&#94;{-2\\pi i n (2x) /8}}&#94;{\\text{even terms}} – \\overbrace{\\sum\\limits_{x = 0}&#94;{4} f(2x + 1) e&#94;{-2\\pi i n (2x+1) /8}}&#94;{\\text{odd terms}} \\\\ &= \\sum\\limits_{x = 0}&#94;{4} f(2x) e&#94;{-2\\pi i n x /4} – \\sum\\limits_{x = 0}&#94;{4} f(2x + 1) e&#94;{-2\\pi i n x /4} e&#94;{-\\pi i n /4}. \\end{align*} c ( n + N /2 ) = x = 0 ∑ 7 ​ f ( x ) e − 2 πin x /8 e − πi x ​ = x = 0 ∑ 4 ​ f ( 2 x ) e − 2 πin ( 2 x ) /8 ​ even terms ​ – x = 0 ∑ 4 ​ f ( 2 x + 1 ) e − 2 πin ( 2 x + 1 ) /8 ​ odd terms ​ = x = 0 ∑ 4 ​ f ( 2 x ) e − 2 πin x /4 – x = 0 ∑ 4 ​ f ( 2 x + 1 ) e − 2 πin x /4 e − πin /4 . ​ The two terms in the resulting equation have remarkable symmetries to the original problem: they are the Fourier transform of the function using only N / 2 N/2 N /2 samples, one using the even indexed samples, the other using the odd indexed samples. Define two new variables for each n n n accordingly: c e ( n ) = ∑ x = 0 4 f ( 2 x ) e − 2 π i n x / 4 c o ( n ) = ∑ x = 0 4 f ( 2 x + 1 ) e − 2 π i n x / 4 , \\begin{align*} c_e(n) &= \\sum\\limits_{x = 0}&#94;{4} f(2x) e&#94;{-2\\pi i n x /4} \\\\ c_o(n) &= \\sum\\limits_{x = 0}&#94;{4} f(2x + 1) e&#94;{-2\\pi i n x /4}, \\end{align*} c e ​ ( n ) c o ​ ( n ) ​ = x = 0 ∑ 4 ​ f ( 2 x ) e − 2 πin x /4 = x = 0 ∑ 4 ​ f ( 2 x + 1 ) e − 2 πin x /4 , ​ we immediately see that c ( n ) = c e ( n ) + c o ( n ) e − π i n / 4 and c ( n + N / 2 ) = c e ( n ) – c o ( n ) e − π i n / 4 . \\begin{align*} c(n)& = c_e(n) + c_o(n) e&#94;{-\\pi i n/4} \\quad \\text{ and} \\\\ c(n + N/2)& = c_e(n) – c_o(n) e&#94;{-\\pi i n/4}. \\end{align*} c ( n ) c ( n + N /2 ) ​ = c e ​ ( n ) + c o ​ ( n ) e − πin /4 and = c e ​ ( n ) – c o ​ ( n ) e − πin /4 . ​ This relationship underlies the \"butterfly diagram\" that the FFT algorithm is known for. Updating our circuit with f e ( x ) = f ( 2 x ) f_e(x) = f(2x) f e ​ ( x ) = f ( 2 x ) and f o ( e ) = f ( 2 x + 1 ) f_o(e) = f(2x+1) f o ​ ( e ) = f ( 2 x + 1 ) : f ( 0 ) = f e ( 0 ) → → ∑ x = 0 3 f e ( x ) = c e ( 0 ) c ( 0 ) = c e ( 0 ) + c o ( 0 ) f ( 2 ) = f e ( 1 ) → Discrete Fouirer Transform → ∑ x = 0 3 f e ( x ) e − 2 π i x / 4 = c e ( 1 ) c ( 1 ) = c e ( 1 ) + c o ( 1 ) e − π i / 4 f ( 4 ) = f e ( 2 ) → → ∑ x = 0 3 f e ( x ) e − 2 π i 2 x / 4 = c e ( 2 ) c ( 2 ) = c e ( 2 ) + c o ( 2 ) e − 2 π i / 4 f ( 6 ) = f e ( 3 ) → → ∑ x = 0 3 f e ( x ) e − 2 π i 3 x / 4 = c e ( 3 ) c ( 3 ) = c e ( 3 ) + c o ( 3 ) e − 3 π i / 4 f ( 1 ) = f o ( 0 ) → → ∑ x = 0 3 f o ( x ) = c o ( 0 ) c ( 4 ) = c e ( 0 ) – c o ( 0 ) f ( 3 ) = f o ( 1 ) → Discrete Fouirer Transform → ∑ x = 0 3 f o ( x ) e − 2 π i x / 4 = c o ( 1 ) c ( 5 ) = c e ( 1 ) – c o ( 1 ) e − π i / 4 f ( 5 ) = f o ( 2 ) → → ∑ x = 0 3 f o ( x ) e − 2 π i 2 x / 4 = c o ( 2 ) c ( 6 ) = c e ( 2 ) – c o ( 2 ) e − 2 π i / 4 f ( 7 ) = f o ( 3 ) → → ∑ x = 0 3 f o ( x ) e − 2 π i 3 x / 4 = c o ( 3 ) c ( 7 ) = c e ( 3 ) – c o ( 3 ) e − 3 π i / 4 \\begin{array}{llll|ccc|llll||l} \\hline f(0) & = & f_e(0) & \\rightarrow & & & & \\rightarrow & \\sum\\limits_{x = 0}&#94;{3} f_e(x) & = & c_e(0) & c(0) = c_e(0) + c_o(0)\\\\ f(2) & = & f_e(1) & \\rightarrow & & \\text{Discrete Fouirer Transform} & & \\rightarrow & \\sum\\limits_{x = 0}&#94;{3} f_e(x) e&#94;{-2\\pi i x /4} & =& c_e(1) & c(1) = c_e(1) + c_o(1) e&#94;{-\\pi i / 4}\\\\ f(4) & = & f_e(2) & \\rightarrow & & & & \\rightarrow & \\sum\\limits_{x = 0}&#94;{3} f_e(x) e&#94;{-2\\pi i 2 x /4} & =& c_e(2) & c(2) = c_e(2) + c_o(2) e&#94;{-2 \\pi i / 4}\\\\ f(6) & = & f_e(3) & \\rightarrow & & & & \\rightarrow & \\sum\\limits_{x = 0}&#94;{3} f_e(x) e&#94;{-2\\pi i 3 x /4} & =& c_e(3) & c(3) = c_e(3) + c_o(3) e&#94;{-3 \\pi i /4} \\\\ \\hline f(1) & = & f_o(0) & \\rightarrow & & & & \\rightarrow & \\sum\\limits_{x = 0}&#94;{3} f_o(x) & =& c_o(0) & c(4) = c_e(0) – c_o(0)\\\\ f(3) & = & f_o(1)& \\rightarrow & & \\text{Discrete Fouirer Transform} & & \\rightarrow & \\sum\\limits_{x = 0}&#94;{3} f_o(x) e&#94;{-2\\pi i x /4} & =& c_o(1) & c(5) = c_e(1) – c_o(1)e&#94;{-\\pi i / 4} \\\\ f(5) & = & f_o(2) & \\rightarrow & & & & \\rightarrow & \\sum\\limits_{x = 0}&#94;{3} f_o(x) e&#94;{-2\\pi i 2 x /4} & =& c_o(2) & c(6) = c_e(2) – c_o(2) e&#94;{-2\\pi i /4} \\\\ f(7) & = & f_o(3) & \\rightarrow & & & & \\rightarrow & \\sum\\limits_{x = 0}&#94;{3} f_o(x) e&#94;{-2\\pi i 3 x /4} & =& c_o(3) & c(7) = c_e(3) – c_o(3) e&#94;{-3\\pi i /4} \\\\ \\hline \\end{array} f ( 0 ) f ( 2 ) f ( 4 ) f ( 6 ) f ( 1 ) f ( 3 ) f ( 5 ) f ( 7 ) ​ = = = = = = = = ​ f e ​ ( 0 ) f e ​ ( 1 ) f e ​ ( 2 ) f e ​ ( 3 ) f o ​ ( 0 ) f o ​ ( 1 ) f o ​ ( 2 ) f o ​ ( 3 ) ​ → → → → → → → → ​ ​ Discrete Fouirer Transform Discrete Fouirer Transform ​ ​ → → → → → → → → ​ x = 0 ∑ 3 ​ f e ​ ( x ) x = 0 ∑ 3 ​ f e ​ ( x ) e − 2 πi x /4 x = 0 ∑ 3 ​ f e ​ ( x ) e − 2 πi 2 x /4 x = 0 ∑ 3 ​ f e ​ ( x ) e − 2 πi 3 x /4 x = 0 ∑ 3 ​ f o ​ ( x ) x = 0 ∑ 3 ​ f o ​ ( x ) e − 2 πi x /4 x = 0 ∑ 3 ​ f o ​ ( x ) e − 2 πi 2 x /4 x = 0 ∑ 3 ​ f o ​ ( x ) e − 2 πi 3 x /4 ​ = = = = = = = = ​ c e ​ ( 0 ) c e ​ ( 1 ) c e ​ ( 2 ) c e ​ ( 3 ) c o ​ ( 0 ) c o ​ ( 1 ) c o ​ ( 2 ) c o ​ ( 3 ) ​ c ( 0 ) = c e ​ ( 0 ) + c o ​ ( 0 ) c ( 1 ) = c e ​ ( 1 ) + c o ​ ( 1 ) e − πi /4 c ( 2 ) = c e ​ ( 2 ) + c o ​ ( 2 ) e − 2 πi /4 c ( 3 ) = c e ​ ( 3 ) + c o ​ ( 3 ) e − 3 πi /4 c ( 4 ) = c e ​ ( 0 ) – c o ​ ( 0 ) c ( 5 ) = c e ​ ( 1 ) – c o ​ ( 1 ) e − πi /4 c ( 6 ) = c e ​ ( 2 ) – c o ​ ( 2 ) e − 2 πi /4 c ( 7 ) = c e ​ ( 3 ) – c o ​ ( 3 ) e − 3 πi /4 ​ ​ We can do this process recursively until we hit the trivial case of a Fourier transfom with one sample. The number of times we will recursively call the algorithm is equal to log ⁡ N \\log N lo g N , because each time the number of terms left in each gets divided by two. At each level of the division, we do N N N constant-time recombinations of the terms in the previous level. Therefore the asymptotic performance of this algorithm should be O ( N log ⁡ N ) O(N \\log N) O ( N lo g N ) , much faster than O ( N 2 ) O(N&#94;2) O ( N 2 ) . Let's code this up and compare runtimes. Again we are going to assume that our input is always going to be a power of two in length. At level l l l back, there are going to be 2 l 2&#94;l 2 l Fourier transforms to compute, each with N / 2 l N/2&#94;l N / 2 l samples. Indexing the output is a lot of fun, in the dwarf fortress sense, as you can see by the following table: Level x Indices 0 0:7 { x } \\{x\\} { x } 1 0:3 { 2 x } \\{2x\\} { 2 x } , { 2 x + 1 } \\{2x+1\\} { 2 x + 1 } 2 0:1 { 2 ( 2 x ) } \\{2(2x)\\} { 2 ( 2 x )} , { 2 ( 2 x ) + 1 } \\{2(2x)+1\\} { 2 ( 2 x ) + 1 } , { 2 ( 2 x + 1 ) } \\{2(2x+1)\\} { 2 ( 2 x + 1 )} , { 2 ( 2 x + 1 ) + 1 } \\{2(2x+1)+1\\} { 2 ( 2 x + 1 ) + 1 } In general the set of indices at any level of the recursion are going to be { 2 l x + n } \\{2&#94;lx +n\\} { 2 l x + n } . Each seperate Fourier transform has a different value of n n n , and for it x x x ranges between 0 0 0 and N / 2 l N/2&#94;l N / 2 l . I suggest working this out yourself to truly grok it. Implementation fast.fourier.transform <- function ( f ) { N <- length ( f ) levels <- log ( N , 2 ) prev.level <- f level <- complex ( real = numeric ( length ( f ))) for ( l in ( levels -1 ) : 0 ) { for ( n in 0 : ( 2 &#94; l - 1 )) { half.num.indices <- 2 &#94; ( levels - l - 1 ) for ( x in 0 : ( half.num.indices - 1 )) { ## One catch here to be aware of: in the circuit diagram above, the two ## seperate Fourier transforms have been placed as if their indices are ## together, for ease of reading. In the implementation, these indices ## are going to be interleaved, i.e. $c_e(0)$ at $i=0$, $c_o(0)$ at $i=1$ ## and so on. Therefore we vary x up to half of the indices, with evens=2x ## and odds=2x+1. level [ 2 &#94; l * x + n + 1 ] = prev.level [ 2 &#94; ( l ) * ( 2 * x ) + n + 1 ] + prev.level [ 2 &#94; l * ( 2 * x +1 ) + n + 1 ] * exp ( complex ( imaginary = - pi * x / half.num.indices )) level [ 2 &#94; l * ( x + half.num.indices ) + n + 1 ] = prev.level [ 2 &#94; l * ( 2 * x ) + n + 1 ] - prev.level [ 2 &#94; l * ( 2 * x + 1 ) + n + 1 ] * exp ( complex ( imaginary = - pi * x / half.num.indices )) } } prev.level <- level } level } slow.fourier.transform <- function ( f ){ N <- length ( f ) result <- numeric ( N ) for ( n in 0 : ( N -1 )) { for ( x in 0 : ( N -1 )) { result [ n +1 ] = result [ n +1 ] + f [ x +1 ] * exp ( complex ( imaginary = -2 * pi * x * n / N )) } } result } Testing Let's test these two functions. Do they give the correct result? Is the fast Fourier transform really faster? For the first question, I'm going to test out the two new series against very simple Fourier series compositions, and also against R 's fft function. For the second question I will test the runtimes with several different length transforms and then compute the relationship between log time and log length. The slow Fourier transform should have a slope of 2, the fast Fourier transform should have a slope that is only slightly higher than 1. What are 4 simple series to test. How about, for x = 0..15 x=0..15 x = 0..15 : Function 1: f ( x ) = sin ⁡ ( 2 π 16 x ) f(x) = \\sin(\\frac{2\\pi}{16} x) f ( x ) = sin ( 16 2 π ​ x ) Function 2: f ( x ) = sin ⁡ ( 2 π 16 x ) – cos ⁡ ( 2 π 16 3 x ) + sin ⁡ ( 2 π 16 6 x ) f(x) = \\sin(\\frac{2\\pi}{16} x) – \\cos(\\frac{2\\pi}{16}3 x) + \\sin(\\frac{2\\pi}{16} 6 x) f ( x ) = sin ( 16 2 π ​ x ) – cos ( 16 2 π ​ 3 x ) + sin ( 16 2 π ​ 6 x ) Function 3: f ( x ) = ∑ n = 0 15 n sin ⁡ ( 2 π 16 n x ) f(x) = \\sum_{n = 0}&#94;{15} n \\sin(\\frac{2 \\pi }{16}n x) f ( x ) = ∑ n = 0 15 ​ n sin ( 16 2 π ​ n x ) Function 4: f ( x ) = ∑ n = 0 15 sin ⁡ ( 2 π 16 n ) sin ⁡ ( 2 π 16 n x ) f(x) = \\sum_{n = 0}&#94;{15} \\sin(\\frac{2\\pi}{16} n )\\sin(\\frac{2 \\pi}{16}n x) f ( x ) = ∑ n = 0 15 ​ sin ( 16 2 π ​ n ) sin ( 16 2 π ​ n x ) library ( ggplot2 ) library ( dplyr ) library ( tidyr ) plot_theme <- theme ( panel.background = element_blank (), panel.grid.major = element_line ( color = \"grey90\" , size = 0.2 ), panel.grid.minor = element_line ( color = \"grey95\" , size = 0.5 ), strip.text.x = element_text ( color = \"white\" ), strip.background = element_rect ( fill = \"black\" ), axis.text = element_text ( color = \"black\" ), axis.title = element_text ( face = \"bold\" ), title = element_text ( face = \"bold\" )) ## Here are the functions we want to test, they should have very clear Fourier transforms function.1 <- function ( x ) sin ( 2 * pi * x / 16 ) function.2 <- function ( x ) sin ( 2 * pi * x / 16 ) - cos ( 2 * pi * 3 * x / 16 ) + sin ( 2 * pi * 6 * x / 16 ) function.3 <- function ( x ) sapply ( x , function ( s ) sum ( sapply ( 0 : 15 , function ( n ) n * sin ( 2 * pi * n * s / 16 )))) function.4 <- function ( x ) sapply ( x , function ( s ) sum ( sapply ( 0 : 15 , function ( n ) sin ( 2 * pi * n / 16 ) * sin ( 2 * pi * n * s / 16 )))) tests <- list ( \"Function 1\" = function.1 , \"Function 2\" = function.2 , \"Function 3\" = function.3 , \"Function 4\" = function.4 ) ## for each of these function, we want to apply the function test.data <- bind_rows ( lapply ( 1 : length ( tests ), function ( i ) { fun <- tests [[ i ]] name <- names ( tests )[[ i ]] x <- 0 : 15 bind_rows ( data.frame ( x = x , y = fun ( x ), func = name , transform = \"None\" ), data.frame ( x = x , y = abs ( fft ( fun ( x ))), func = name , transform = \"fft\" ), data.frame ( x = x , y = abs ( slow.fourier.transform ( fun ( x ))), func = name , transform = \"slow.fourier.transform\" ), data.frame ( x = x , y = abs ( fast.fourier.transform ( fun ( x ))), func = name , transform = \"fast.fourier.transform\" )) })) test.data $ transform <- factor ( test.data $ transform , levels = c ( \"None\" , \"slow.fourier.transform\" , \"fast.fourier.transform\" , \"fft\" )) ggplot ( data = test.data , aes ( x = x , y = y )) + geom_point () + facet_grid ( func ~ transform , scale = \"free\" ) + theme_bw () As you can see via the above plot, the code that we've written agrees with R's built in fft function, which is good. Also good is that it gives the output that we expect. You might be wondering why the first row of plots contain two non-zero dots each – wasn't there just one frequency included in function 1? Remember that to put in this function, we used sin ⁡ ( x ) = ( e i x – e − i x ) / 2 i \\sin(x) = (e&#94;{ix} – e&#94;{-ix})/2i sin ( x ) = ( e i x – e − i x ) /2 i , the other point that shows up is the \"negative\" frequency which has show up on the other side due to the periodic symmetry of the complex exponential. Timing Now let's time the functions against several different length inputs and see how they behave as the length of the sequences get large. sequence.lengths <- sapply ( 0 : 13 , function ( x ) 2 &#94; x ) timing.test <- data.frame ( length = sequence.lengths , slow = sapply ( sequence.lengths , function ( l ) { dat <- 0 : l ; system.time ({ slow.fourier.transform ( dat )})[[ \"elapsed\" ]]}), fast = sapply ( sequence.lengths , function ( l ) { dat <- 0 : l ; system.time ({ fast.fourier.transform ( dat )})[[ \"elapsed\" ]]}), fft = sapply ( sequence.lengths , function ( l ) { dat <- 0 : l ; system.time ({ fast.fourier.transform ( dat )})[[ \"elapsed\" ]]})) timing.test <- gather ( timing.test , func , time , slow , fast , fft ) Normal plot: ggplot ( data = timing.test , aes ( x = length , y = time , color = func )) + geom_point () + theme_bw () Log-Log-plot: ggplot ( data = timing.test , aes ( x = log ( length ), y = log ( time ), color = func )) + geom_point () + theme_bw () + geom_smooth ( method = \"lm\" ) + coord_fixed ( ratio = 1 ) Linear models on the log-log data slow <- subset ( timing.test , func %in% \"slow\" & time != 0 ) fast <- subset ( timing.test , func %in% \"fast\" & time != 0 ) fft <- subset ( timing.test , func %in% \"fft\" & time != 0 ) lm.slow <- lm ( log ( time ) ~ log ( length ), data = slow ) lm.slow ## ## Call: ## lm(formula = log(time) ~ log(length), data = slow) ## ## Coefficients: ## (Intercept) log(length) ## -11.889 1.974 m.fast <- lm ( log ( time ) ~ log ( length ), data = fast ) lm.fast ## ## Call: ## lm(formula = log(time) ~ log(length), data = fast) ## ## Coefficients: ## (Intercept) log(length) ## -10.334 1.132 m.fft <- lm ( log ( time ) ~ log ( length ), data = fft ) lm.fft ## ## Call: ## lm(formula = log(time) ~ log(length), data = fft) ## ## Coefficients: ## (Intercept) log(length) ## -9.855 1.078 Via the coefficient on log(length) we see that the slow version has slope approximately equal to 2, and the fast version has slope slightly greater than one. I'm especially suprised that my version in plain R seems to perform nearly as fast as R's native fft function, which I had assumed was programmed in optimized C. Thus we have derived the a way in which the discrete Fourier transform can be computed O ( N log ⁡ N ) O(N\\log N) O ( N lo g N ) . Further Reading Gilbert Strang gives a really good lecture on FFT, using matrix factorization which I didn't cover here. (Unfortunately lost me around 37:25). link Citations [1] Fourier, Joseph (1822). ThÃ©orie analytique de la chaleur (in French). Paris: Firmin Didot PÃ¨re et Fils. OCLC 2688081. link [2] Cooley, James W.; Tukey, John W. (1965). \"An algorithm for the machine calculation of complex Fourier series\". Math. Comput. 19: 297â€\"301. doi:10.2307/2003354 . link [3] Cooley, J. W. (1987). The re-discovery of the fast Fourier transform algorithm. Microchimica Acta, 93(1-6), 33-45. link Share this: Click to share on Twitter (Opens in new window) Click to share on Facebook (Opens in new window) Click to share on Google+ (Opens in new window) Related Posted in: Uncategorized 3 Comments hughw March 20, 2017 at 4:43 pm In computational seismology we've long had our own creation story for the FFT: \"The first machine computation with this algorithm known to the author was done by Vern Herbert, who used it extensively in the interpretation of reflection seismic data. He programmed it on an IBM 1401 computer at Chevron Standard Ltd., Calgary, Canada in 1962. Herbert never published the method. It was rediscovered and widely publicized by Cooley and Turkey in 1965.\" [1] [1] Claerbout, J., 1985, Fundamentals of Geophysical Data Processing, p. 12. Reply Avi Levy March 20, 2017 at 5:40 pm You might judge these comments to be pedantic, but I thought it would be best to share anyway, since they lead to more interesting history on the Fourier Transform from a mathematical perspective. 1. \"To review, you can approximate any function over an interval of length L with sines and cosines with period equal to L:\" > Depends on what you mean by \"approximate\" and what you mean by \"any function\". If you only require the Fourier series to converge at \"most\" points, then Carleson's Theorem [1] (only proven in 1966 after a lot of searching over the years!) is the definitive result. It says the Fourier series will converge pointwise to the value of the function for almost all values of x if the function raised to all powers strictly grater than 1 has a finite integral over the interval of length L. > Let me also add that the question of which functions could be represented by a Fourier Series was the subjective of enormous debate in 19th century mathematics involving Poincare and others. [2] 2. \"… and 0 of m≠n. This can be used to isolate c_m:\" and a few lines later \"The output of the Fourier transform is the set of c_m's\" > This is right before the start of the Discrete Fourier Series section. The first \"of\" should be \"if\", the word \"set\" should be \"sequence\", and I think you managed to get a backwards apostrophe on the last c_m. 3. \"This is effectively computing the integral with a rectangular approximation\" … \"runtime of this circuit\" … \"butterfly diagram\" > This is called a Riemann sum. [3] Also it is unclear what circuit you are referring to, doesn't it make sense to simply say that N&#94;2 terms must be added to compute f(0), …, f(N-1) in this manner? Lastly, it seems cryptic to refer to the butterfly diagram without including or linking to a picture of what it is you have in mind. 4. Citations: \"ThÃ©orie analytique de la chaleur (in French). Paris: Firmin Didot PÃ¨re et Fils.\" and \"An algorithm for the machine calculation of complex Fourier series\". Math. Comput. 19: 297â€\" > There are some symbols that aren't rendering correctly for me in your citations list (they appear to mostly be accents), and again a backwards quotation mark has snuck in. Overall nice writeup. The whole point of the FFT can be expressed quite concisely: it is a classic example of a \"divide and conquer\" algorithm, and such algorithms typically yield speedups that replace a factor of N by log N. I would have written something to this effect earlier on to get the main point across, rather than focusing on the details before getting the main point across. [1] https://en.wikipedia.org/wiki/Carleson's_theorem [2] http://henripoincarepapers.univ-lorraine.fr/chp/text/michelson.html [3] https://en.wikipedia.org/wiki/Riemann_sum Reply Paul Becker March 20, 2017 at 6:04 pm Great article. FYI, In several places, \"Fourier\" is misspelled as \"Fouirer\". Reply","tags":"misc","url":"https://michaeljflynn.net/history-and-derivation-of-the-fast-fourier-transform.html","loc":"https://michaeljflynn.net/history-and-derivation-of-the-fast-fourier-transform.html"},{"title":"A Tutorial on Principal Component Analysis","text":"Note: imported from an earlier version of this blog. Introduction Machine learning is a buzzword these days. Just dropping it can impress people without requiring that you elaborate, perhaps because it feeds their fantasies of a robot takeover. Investors are particularly vulnerable because they get to act on these fantasies. The following exchange approximates one that actually happened in real life: \"We've got a couple cutting edge projects coming down the pipeline: cloud computing and machine learning !\" \"Wow! I'm terribly excited about all this! Hail our new overlords! Take my money!\" Notice that money changed hands without inquiry into what these two concepts were being used for. All this means is that, whoever you are, it is especially important to become familiar with the real tools of machine learning and data science, what problems they are meant to solve, and how they solve them. This is a tutorial on \"principal component analysis\", or PCA, a technique used to reduce redundancy in your data. In any given dataset, you might have two or more measurements that actually measure the same thing. One example would be a dataset measuring students' hours spent doing schoolwork and their GPA. These 2 variables could be interpreted as measuring 1 underlying quality of a student: how much of a \"good student\" they are. We might want to reduce these 2 factors into this \"good student\" measure because this greatly simplifies statistical analysis. That's where PCA comes in. PCA rotates your data's coordinate system to one that aligns with the important questions i.e. whether a student is a good student or not (GPA + hours worked), or how naturally smart or efficient they are (GPA – hours worked). It also gives a score on how important these factor are. In this tutorial I am going to set up a situation where there is one underlying phenomenon: the motion of a spring in one direction. I'm going to duplicate and obfuscate this phenomenon by having a fictional group of scientist measure this it with several different cameras. Then I'm going to use PCA to isolate the signal. Setting up redundant data Let's say we have a ball attached to a spring. The balls motion might be described as x ( t ) = c o s ( t ) x(t) = cos(t) x ( t ) = cos ( t ) around the equilibrium point. I can model this in R. library ( ggplot2 ) library ( tidyr ) library ( dplyr ) theme_set ( theme_bw ()) # set default theme to black-white t <- seq ( 0 , 6 * pi , by = . 1 ) x <- cos ( t ) qplot ( x = t , y = x ) The above plot is how the position x x x varies with time. Of course, in the real world the ball has 3 spatial coordinates and every measurement has noise. To account for these I'm going to add y y y and z z z coordinates, which are both 0 and I'm also going to add noise in every direction. positions <- data.frame ( t = seq ( 0 , 6 * pi , by = . 1 ), x = x + rnorm ( length ( x ), sd = . 1 ), y = rnorm ( length ( x ), sd = . 1 ), z = rnorm ( length ( x ), sd = . 1 )) ggplot ( data = gather ( positions , variable , value , x : z ), aes ( x = t , y = value )) + geom_point () + facet_wrap ( ~ variable , nrow = 1 ) Now you can see 3 relationships, one of mostly signal, 2 of noise. Now let's say a team of scientists have set up 3 cameras to observe this process. They do not have priviledged access to the coordinate system that we know of, where the x x x coordinate contains all the signal. Rather, for each camera they get two coordinates: the x x x and y y y of the ball's location in the camera's image plane. For simplicity's sake, I'm going to assume each camera is pointed directly at the midpoint of the ball's motion. I'm going to assert, and you can prove to yourself, that a camera's image plane coordinates can be expressed by rotating and scaling the original coordinate system, and then projecting the data onto two of the resulting dimensions. One side note: In the process of writing this post, I discovered that generating a random 3D-rotation is actually super annoying. I spent a little bit of time trying to tie the concept down and this is what I've come up with: a rotation can be uniquely specified by an axis and an angle to rotate around that axis. You can read about all that here and here , or you can just steal my code. ## random 3d rotation matrix random.rotation.matrix <- function ( seed ) { set.seed ( seed ) ## angle around vector to rotate psi <- runif ( 1 , max = 2 * pi ) ## select a random point on S&#94;2 phi <- runif ( 1 , max = 2 * pi ) theta <- acos ( 2 * runif ( 1 ) - 1 ) ## construct axis from random S&#94;2 point axis <- c ( cos ( theta ) * cos ( phi ), cos ( theta ) * sin ( phi ), sin ( theta )) ## cross product matrix for formula axis.cp <- matrix ( c ( 0 , - axis [ 3 ], axis [ 2 ], axis [ 3 ], 0 , - axis [ 1 ], - axis [ 2 ], axis [ 1 ], 0 ), nrow = 3 , byrow = TRUE ) ## create rotation matrix using wikipedia formula R <- cos ( psi ) * diag ( c ( 1 , 1 , 1 )) + sin ( psi ) * axis.cp + ( 1 - cos ( psi )) * outer ( axis , axis ) R } I've tested the above function and it does seem to create random rotations. So let's go ahead an find the new coordinates! new.camera.data <- function ( positions , seed ) { set.seed ( seed ) ## original data original.coordinates <- t ( as.matrix ( select ( positions , x , y , z ))) ## get scale scale <- 1 / rexp ( 1 , 1 / 3 ) ## get rotation rotation <- random.rotation.matrix ( seed ) ## new points new.points <- t ( scale * rotation %*% original.coordinates ) ## project image.plane.projection <- new.points [, 1 : 2 ] list ( scale = scale , rotation = rotation , data = image.plane.projection ) } camera.1 <- new.camera.data ( positions , 1 ) camera.2 <- new.camera.data ( positions , 2 ) camera.3 <- new.camera.data ( positions , 3 ) camera.data = data.frame ( t = seq ( 0 , 6 * pi , by = . 1 ), x1 = camera.1 $ data [, 1 ], y1 = camera.1 $ data [, 2 ], x2 = camera.2 $ data [, 1 ], y2 = camera.2 $ data [, 2 ], x3 = camera.3 $ data [, 1 ], y3 = camera.3 $ data [, 2 ]) ggplot ( data = gather ( camera.data , variable , value , x1 : y3 ), aes ( x = t , y = value )) + geom_point () + facet_wrap ( ~ variable , nrow = 2 ) It now looks that there are several signals here, but the scientists are suspicious because they seem very correlated. How will they isolate the signal? Finding the Principal Components PCA is based on the hypothesis that signals are things that cause your data to vary. Therefore, directions that possess large signals will also have data that varies in that direction. This leads us to the fundamental assumption of PCA: Fundamental Assumption of PCA: The most important directions are the directions in which the data varies most . Note that this implicitly assumes that the signal to noise ratio, σ s i g n a l 2 σ n o i s e 2 > 1. \\frac{\\sigma_{signal}&#94;2}{\\sigma_{noise}&#94;2}> 1. σ n o i se 2 ​ σ s i g na l 2 ​ ​ > 1. Only then will the signal directions be expected to be the directions of greatest variation. It many real-world applications, for example stock price forecasting, the noise overwhelms the signal. It would be an interesting exercise to see how this simple example breaks down as you add noise. Thus, PCA becomes an optimization problem. Let the matrix of data with each column translated so that it is mean 0 ( a → a – m e a n ( a ) a \\to a–mean(a) a → a – m e an ( a ) ) be denoted X \\mathbf X X . You will soon see why this translation is important. Since translation does not effect variance, we are trying to find some unit vector u \\mathbf u u such that the variance of X u \\mathbf X \\mathbf u Xu is maximized. Maximize Var( X u ) subject to ∣ ∣ u ∣ ∣ = 1 , \\text{Maximize Var(}{\\mathbf X \\mathbf u} \\text{)} \\quad \\text{ subject to } \\quad ||\\mathbf u|| = 1, Maximize Var( Xu ) subject to ∣∣ u ∣∣ = 1 , repeatedly such that each u i ⋅ u j = 0 \\mathbf u_i \\cdot\\mathbf u_j = 0 u i ​ ⋅ u j ​ = 0 for i ≠ j i \\neq j i  = j until our directions span the space of the data. To solve this, let's talk about variance for a bit. Consider two sets of measurements a = { a 1 , a 2 , … , a n } and b = { b 1 , b 2 , … , b n } \\mathbf a = \\{ a_1, a_2,…, a_n\\} \\quad \\text{ and } \\quad \\mathbf b = \\{b_1, b_2,…,b_n\\} a = { a 1 ​ , a 2 ​ , … , a n ​ } and b = { b 1 ​ , b 2 ​ , … , b n ​ } with means of μ a \\mu_a μ a ​ and μ b \\mu_b μ b ​ , respectively. The variance and covariance are defined as average squared differences from the mean: Var ( a ) = σ a 2 = 1 n ∑ i ( a i – μ a ) 2 = 1 n ∑ i a i 2 = 1 n a ⋅ a if μ a = 0 , \\text{Var}(\\mathbf a) = \\sigma_{\\mathbf a}&#94;2 = \\frac{1}{n} \\sum_i(a_i – \\mu_a)&#94;2 = \\frac{1}{n} \\sum_i a_i&#94;2 = \\frac{1}{n} \\mathbf a \\cdot \\mathbf a \\quad \\text{if } \\mu_a = 0, Var ( a ) = σ a 2 ​ = n 1 ​ i ∑ ​ ( a i ​ – μ a ​ ) 2 = n 1 ​ i ∑ ​ a i 2 ​ = n 1 ​ a ⋅ a if μ a ​ = 0 , Cov ( a , b ) = σ a b 2 = 1 n ∑ i ( a i – μ a ) ( b i – μ b ) = 1 n ∑ i a i b i = 1 n a ⋅ b if μ a = 0 and μ b = 0. \\text{Cov}(\\mathbf a, \\mathbf b) = \\sigma_{\\mathbf{ab}}&#94;2 = \\frac{1}{n} \\sum_i(a_i – \\mu_a)(b_i – \\mu_b) = \\frac{1}{n} \\sum_i a_ib_i = \\frac{1}{n}\\mathbf a \\cdot \\mathbf b \\quad \\text{if } \\mu_a =0 \\text{ and } \\mu_b = 0. Cov ( a , b ) = σ ab 2 ​ = n 1 ​ i ∑ ​ ( a i ​ – μ a ​ ) ( b i ​ – μ b ​ ) = n 1 ​ i ∑ ​ a i ​ b i ​ = n 1 ​ a ⋅ b if μ a ​ = 0 and μ b ​ = 0. So the variance is equal to the covariance of a variable with itself, Var ( a ) = Cov ( a , a ) . \\text{Var}(\\mathbf{a}) = \\text{Cov}(\\mathbf a, \\mathbf a). Var ( a ) = Cov ( a , a ) . Since all of X \\mathbf X X 's columns x i \\mathbf x_i x i ​ , are mean zero, we can define a matrix C \\mathbf C C where the ( i , j ) th (i,j)\\text{th} ( i , j ) th member is the covariance of x i \\mathbf x_i x i ​ and x j \\mathbf x_j x j ​ . 1 n X T X = [ 1 n x 1 ⋅ x 1 ⋯ 1 n x 1 ⋅ x r ⋮ ⋱ ⋮ 1 n x r ⋅ x 1 ⋯ 1 n x r ⋅ x r ] = C . \\frac{1}{n} \\mathbf X&#94;T \\mathbf X = \\begin{bmatrix} \\frac{1}{n} \\mathbf x_1 \\cdot \\mathbf x_1 & \\cdots & \\frac{1}{n} \\mathbf x_1 \\cdot \\mathbf x_r \\\\ \\vdots & \\ddots & \\vdots \\\\ \\frac{1}{n} \\mathbf x_r \\cdot \\mathbf x_1 & \\cdots & \\frac{1}{n} \\mathbf x_r \\cdot \\mathbf x_r \\end{bmatrix} = \\mathbf C. n 1 ​ X T X = ​ n 1 ​ x 1 ​ ⋅ x 1 ​ ⋮ n 1 ​ x r ​ ⋅ x 1 ​ ​ ⋯ ⋱ ⋯ ​ n 1 ​ x 1 ​ ⋅ x r ​ ⋮ n 1 ​ x r ​ ⋅ x r ​ ​ ​ = C . Let's do this now with our camera measurments in R. options ( width = 120 ) measurements <- select ( camera.data , - t ) measurements <- mutate_each ( measurements , funs ( . - mean ( . ))) measurements <- as.matrix ( measurements ) covariance.matrix <- t ( measurements ) %*% measurements / nrow ( measurements ) covariance.matrix ## x1 y1 x2 y2 x3 y3 ## x1 0.0021234862 -0.005043854 -0.0002620748 -0.002255248 -0.0005278387 -0.002325504 ## y1 -0.0050438535 0.092671234 0.0166668085 0.034679534 0.0217014469 0.034022588 ## x2 -0.0002620748 0.016666808 0.0032414307 0.006126479 0.0041287510 0.005953620 ## y2 -0.0022552479 0.034679534 0.0061264792 0.013067542 0.0079891875 0.012826169 ## x3 -0.0005278387 0.021701447 0.0041287510 0.007989187 0.0053130622 0.007799908 ## y3 -0.0023255041 0.034022588 0.0059536201 0.012826169 0.0077999083 0.012612169 Let's also reframe our optimization problem in terms of this nice, square, symmetric matrix: Var ( X u ) = 1 n ( X u ) T ( X u ) = u T ( 1 n X T X ) u = u T C u . \\text{Var}(\\mathbf{X} \\mathbf u) = \\frac{1}{n}(\\mathbf{X} \\mathbf u)&#94;T (\\mathbf{X} \\mathbf u) = \\mathbf u&#94;T (\\frac{1}{n} \\mathbf{X}&#94;T \\mathbf{X}) \\mathbf u = \\mathbf u&#94;T \\mathbf{C} \\mathbf u. Var ( Xu ) = n 1 ​ ( Xu ) T ( Xu ) = u T ( n 1 ​ X T X ) u = u T Cu . Therefore we are trying find a u \\mathbf u u that maximizes the matrix product with the covariance matrix, u T C u \\mathbf u&#94;T \\mathbf C \\mathbf u u T Cu such that u \\mathbf u u is a unit vector and perpendicular to the other solutions we have found. Remember that C \\mathbf C C is a square, symmetric matrix, and its set of unit eigenvectors { v 1 , v 2 , … , v r } \\{\\mathbf v_1, \\mathbf v_2,\\dots, \\mathbf v_r\\} { v 1 ​ , v 2 ​ , … , v r ​ } are orthogonal , i.e. v i ⋅ v j = 0 \\mathbf v_i \\cdot \\mathbf v_j = 0 v i ​ ⋅ v j ​ = 0 for i ≠ j i \\neq j i  = j , and span it's column and row spaces. Therefore we can express u \\mathbf u u as some combination of the orthogonal unit eigenvectors of C \\mathbf C C : u = a 1 v 1 + a 2 v 2 + ⋯ + a r v r , \\mathbf u = a_1 \\mathbf v_1 + a_2 \\mathbf v_2 + \\dots + a_r \\mathbf v_r, u = a 1 ​ v 1 ​ + a 2 ​ v 2 ​ + ⋯ + a r ​ v r ​ , where ∑ a i 2 = 1 \\sum a_i&#94;2 = 1 ∑ a i 2 ​ = 1 to make the result length 1. What happens when we make this substitution into the quantity we are trying to optimize? u T C u = ( a 1 v 1 T + a 2 v 2 T + ⋯ + a r v r T ) C ( a 1 v 1 + a 2 v 2 + ⋯ + a r v r ) = ( a 1 v 1 T + a 2 v 2 T + ⋯ + a r v r T ) ( a 1 C v 1 + a 2 C v 2 + ⋯ + a r C v r ) = ( a 1 v 1 T + a 2 v 2 T + ⋯ + a r v r T ) ( a 1 λ 1 v 1 + a 2 λ 2 v 2 + ⋯ + a r λ r v r ) = a 1 2 λ 1 + a 2 2 λ 2 + ⋯ + a r 2 λ r because the v ‘s are orthogonal. \\begin{align*} \\mathbf u&#94;T \\mathbf C \\mathbf u &= (a_1 \\mathbf v_1&#94;T + a_2 \\mathbf v_2&#94;T + \\dots + a_r \\mathbf v_r&#94;T) \\mathbf C (a_1 \\mathbf v_1 + a_2 \\mathbf v_2 + \\dots + a_r \\mathbf v_r) \\\\ &= (a_1 \\mathbf v_1&#94;T + a_2 \\mathbf v_2&#94;T + \\dots + a_r \\mathbf v_r&#94;T) (a_1 \\mathbf C \\mathbf v_1 + a_2 \\mathbf C \\mathbf v_2 + \\dots + a_r \\mathbf C \\mathbf v_r) \\\\ &= (a_1 \\mathbf v_1&#94;T + a_2 \\mathbf v_2&#94;T + \\dots + a_r \\mathbf v_r&#94;T) (a_1 \\lambda_1 \\mathbf v_1 + a_2 \\lambda_2 \\mathbf v_2 + \\dots + a_r \\lambda_r \\mathbf v_r) \\\\ &= a_1&#94;2 \\lambda_1 + a_2&#94;2 \\lambda_2 + \\dots + a_r&#94;2 \\lambda_r \\quad \\text{because the } \\mathbf v \\text{‘s are orthogonal.}\\end{align*} u T Cu ​ = ( a 1 ​ v 1 T ​ + a 2 ​ v 2 T ​ + ⋯ + a r ​ v r T ​ ) C ( a 1 ​ v 1 ​ + a 2 ​ v 2 ​ + ⋯ + a r ​ v r ​ ) = ( a 1 ​ v 1 T ​ + a 2 ​ v 2 T ​ + ⋯ + a r ​ v r T ​ ) ( a 1 ​ C v 1 ​ + a 2 ​ C v 2 ​ + ⋯ + a r ​ C v r ​ ) = ( a 1 ​ v 1 T ​ + a 2 ​ v 2 T ​ + ⋯ + a r ​ v r T ​ ) ( a 1 ​ λ 1 ​ v 1 ​ + a 2 ​ λ 2 ​ v 2 ​ + ⋯ + a r ​ λ r ​ v r ​ ) = a 1 2 ​ λ 1 ​ + a 2 2 ​ λ 2 ​ + ⋯ + a r 2 ​ λ r ​ because the v ‘s are orthogonal. ​ This is very interesting. Let { α 1 , α 2 , … , α r } = { a 1 2 , a 2 2 , … , a r 2 } , \\{\\alpha_1, \\alpha_2, …, \\alpha_r \\} = \\{a_1&#94;2, a_2&#94;2, …, a_r&#94;2\\}, { α 1 ​ , α 2 ​ , … , α r ​ } = { a 1 2 ​ , a 2 2 ​ , … , a r 2 ​ } , we are trying to solve an optimization of the form Maximize α 1 λ 1 + α 2 λ 2 + ⋯ + α r λ r Subject to ∑ i α i = 1 All α i ≥ 0 \\begin{align*} \\text{Maximize} \\quad \\alpha_1 \\lambda_1 + &\\alpha_2 \\lambda_2 + \\dots + \\alpha_r \\lambda_r \\\\ \\text{Subject to} \\quad \\sum_i \\alpha_i &= 1 \\\\ \\text{All } \\alpha_i & \\geq 0 \\end{align*} Maximize α 1 ​ λ 1 ​ + Subject to i ∑ ​ α i ​ All α i ​ ​ α 2 ​ λ 2 ​ + ⋯ + α r ​ λ r ​ = 1 ≥ 0 ​ This is a linear programming problem, where all solutions will be on the corners of the space. On the corners, the inequalities are tight, so the solutions are where r − 1 r-1 r − 1 α \\alpha α 's are 0, and exactly one α i = 1 \\alpha_i = 1 α i ​ = 1 , so a i = α i = 1 a_i = \\sqrt{\\alpha_i} = 1 a i ​ = α i ​ ​ = 1 . So u i = v i \\mathbf u_i = \\mathbf v_i u i ​ = v i ​ , where the i th i\\text{th} i th most important direction has the i th i\\text{th} i th largest eigenvalue. The solutions are the eigenvectors of the covariance matrix. Since the eigenvalues are orthogonal, our coordinate system is orthogonal. Pretty cool result, if you ask me. Isolating the signal Some people use the singular SVD to get the eigenvectors and eigenvalues. If there is a deeper reason to use SVD, feel free to email me! I am curious. Here, I'm just going to use the R function eigen to grab the eigenvectors. First I'm going to look at the eigenvalues. I expect to see 1 large eigenvalue, and 5 much smaller values. What I'm going to do then is get the eigenvectors, project the data into that basis, and plot the results. important.directions <- eigen ( covariance.matrix ) important.directions $ value ## [1] 1.265056e-01 2.491410e-03 3.188713e-05 1.083847e-17 3.857996e-18 -2.696033e-18 The first eigenvalue is 100x bigger than the second, which is 100x bigger than the next, and so on. This is exactly what I hoped to see. projected <- as.data.frame ( measurements %*% important.directions $ vector ) colnames ( projected ) <- paste0 ( \"component\" , 1 : 6 ) projected $ t <- camera.data $ t plot.data <- gather ( projected , component , value , component1 : component6 ) ggplot ( data = plot.data , aes ( x = t , y = value )) + geom_point () + facet_wrap ( ~ component ) We've not only isolated the signal, we've also isolated the noise as well! PCA has saved the scientists from the complicated analysis of 6 signals, and given them only one to work with. Problem solved. Further reading Jonathan Schlen's Tutorial on PCA Stack exchange post on PCA","tags":"misc","url":"https://michaeljflynn.net/a-tutorial-on-principal-component-analysis.html","loc":"https://michaeljflynn.net/a-tutorial-on-principal-component-analysis.html"},{"title":"Alice, The Alien, and the Illusion of the Twin Paradox","text":"Note: imported from an earlier version of this blog. Sorry if anything is broken. Alice is traveling through deep space with her alien navigator. They are delivering a shipment of water to Proxima Centauri at a solid fraction of light speed. They had been traveling in deep space at constant speed for so long that it was as if they were standing still. Suddenly, and with a flash of light, they pass another interstellar traveler, one Robert, heading back to Earth. Sensor readings on Alice's ship have him traveling at 3/5 light speed relative to them. \"Bob's foot is made of solid lead,\" the Alien commented. \"It better be when he has to slow down.\" Alice took a moment to consider the significance of this event. \"Reality is so strange. Bob is speeding past us right now. According to special relativity, time should be passing slower for him. However, special relativity also says that he has every right to say that he is stationary and we are moving, and therefore time is passing slower for us. Who is right?\" \"Both.\" The Alien blinked. Alice continued. \"One of us could start accelerating towards the other to meet up and find out which one was aging faster, but whoever does the acceleration will find that they had aged as if they were the ones moving the whole time! It's almost like acceleration breaks the symmetry.\" The Alien squinted his big black eyes. \"Well, I guess.\" \"Don't you think that's weird? That's how the real world works!\" The Alien shrugged, looking back at his console. \"Not really.\" Alice sighed. She wasn't particularly surprised that the Alien wasn't playing along. He had a habit of shooting down her conversation topics. She went on. \"I guess the core of the paradox is that we both have an equal right to say that we are the more aged person while we are both moving at constant speed. Special relativity says that we are both right, but how could that be possible?\" The Alien turned. \"What do you mean when we arrive at the station?\" \"I mean the moment in time when our ship's coordinates become coincident with the station's coordinates.\" said Alice, frustrated. \"What do you mean moment in time ?\" asked the Alien, with a grin. \"I'm going to go re-hydrate some noodles.\" He clapped his hands excitedly and went to go pull out some noodles from the freezer. Now the Alien was just being obtuse. Alice was determined to get through his philosophical meanderings. \" I mean the slice of all points in space-time where every synced clock traveling parallel to us at the same speed would read the same number as our clock.\" \"But-\", the Alien began but Alice interrupted him, anticipating his question and being a gifted experimentalist. \"You could easily sync clocks using a laser. All you need to do is fire a pulse at the clock. When the reflection comes back, you know that the clock is exactly half of the elapsed lightseconds away and it has advanced by exactly half the number of seconds the total journey took. Add that number to the reflected value on the clock and then you are synced.\" Alice drew a diagram. \"Here's a chart with time on the y-axis and distance in line with the direction to the clock on the x-axis. I've scaled the axes so that light moves at 45 degree angles. Here you can see how the mechanism works. The red line is the laser pulse. All the spacetime points on the horizontal dotted line make up the moment in time, the present , when we hit the station, because any laser pulse reflected off a clock at any of those points makes a 45-45-90 triangle, who's altitude from the 90 bisects the base. Do you get it?\" The Alien nodded. Alice continued. \"In fact, we don't even need a clock. We know that when we receive the reflection of the laser, whatever it bounced off of must have been simultaneous with whatever was happening on our ship exactly halfway through the round trip. We could even do this with Bob. I know his speed relative to me is 3/5 light speed. In 30 months, when we arrive at the station, he will be 18 light months away. I can send out a laser pulse in 12 months that will hit him exactly at (30 months, 18 lightmonths), which is when I arrive at the station. It will return to me. What will the reflection read out? Well, I remember a special trick for measuring straight-line clock-time from special relativity class: Δ u = Δ t 2 − Δ x 2 \\Delta u = \\sqrt{\\Delta t&#94;2 - \\Delta x&#94;2} Δ u = Δ t 2 − Δ x 2 ​ , where Δ x \\Delta x Δ x is in light-units. So his clock reads 3 0 2 − 1 8 2 = 24 \\sqrt{30&#94;2 - 18&#94;2}=24 3 0 2 − 1 8 2 ​ = 24 months greater than the time when we crossed paths, confirming that he has aged less than the 30 months we will have aged!\" \"But how does that make any sense?\" asked Alice, still stumped. \"Perhaps Bob's reference frame is in a different universe. Maybe we are now split into multiverses .\" \"Hold on a second,\" pleaded the Alien. \"Bob can do the same to us. He can wait 12 months, which due to time dilation is 15 months for us, and send a laser pulse towards us. When he receives the reflection, he knows he can go back half the round-trip time to the exact moment on his timeline where the laser hit us. And it seems the laser hits us at… 24 weeks, which is perfectly symmetrical, but…\" He edited the diagram. \"Bob knows that the laser pulse hit you when your clock had elapsed 24 months, and that must be at the same time as when his clock read 30 months. However, these two events do not happen at the same time in our reference frame. There is no paradox, but Bob's present is tilted relative to ours. That's what causes the illusion of contradiction. At the event at which you have accused Bob of being younger than us, to him you are not even close to reaching the station.\" The Alien said, translating Bob's present line down. The Alien plopped a bowl of noodles in front of Alice. She was shocked. \"So we are both right, in our own reference frames, and there isn't any contradiction because the present is relative?\" she asked. She paused for a moment, tired of thinking. \"Thanks for the soup.\" \"You're welcome.\" said the Alien. They sipped in silence. All diagrams made using the diagrams library by Brent Yorgey. Note: This post closely follows the approach of Tim Maudlin in his book: Philosophy of Physics: Space and Time (Princeton Foundations of Contemporary Philosophy) . It is an excellent book. Maudlin is concrete where many philosophers are abstract and fluffy. He also understands physics better than many physicists. The great Richard Feynman gave an incorrect, acceleration symmetry-breaking explanation to this phenomenon.","tags":"misc","url":"https://michaeljflynn.net/alice-the-alien-and-the-illusion-of-the-twin-paradox.html","loc":"https://michaeljflynn.net/alice-the-alien-and-the-illusion-of-the-twin-paradox.html"},{"title":"Simple RNA folding in 130 lines of Haskell","text":"Note: imported from an earlier version of this blog. Sorry if anything is broken . How do we predict how RNA folds? First of all, we need to define what we mean by folding. RNA is a polymer made up of nucleic acids: adenine, guanine, cytosine, and uracil. There are 3 levels of RNA structure that are traditionally considered: primary structure: the sequence of bases, ‘A', ‘G', ‘C', and ‘U' that form the strand of RNA, ‘AAAAGGGGCCCCUUUU' for example, secondary structure: which bases are hydrogen bonded together, ‘A' to ‘U' and ‘G' to ‘C', can be specified by a sequence of pairs corresponding to which indices are paired together (1,24), (2,23)…, and tertiary structure: how the molecule bends on itself on a larger scale. Usually, primary structure is already known or given as an input and tertiary structure is hard to specify and compute the energy for. Secondary structure is easy to specify using a sequence of pairs and the energy is roughly dominated by hydrogen bonding between bases which is discrete. Since RNA functions mostly by binding to things using exposed (non-paired) bases, the secondary structure is also the most relevant when discerning function. For these reasons, biophysicists usually focus on predicting the secondary structure of RNA. From the laws of thermal physics, if RNA is modeled as a system in thermal equilibrium then the probability of any state s s s with free energy E ( s ) E(s) E ( s ) is equal to P ( s ) = e − E ( s ) / k T ∑ s ′ ∈ S e − E ( s ′ ) / k T , P(s)= \\frac{e&#94;{-E(s)/kT}}{\\sum_{s' \\in S} e&#94;{-E(s')/kT}}, P ( s ) = ∑ s ′ ∈ S ​ e − E ( s ′ ) / k T e − E ( s ) / k T ​ , where S S S is the full set of states. The denominator is called the partition function , usually denoted Z Z Z , it normalizes the probability distribution and with it we can compute the probability of any structure. How many terms are in the partition function? How many states are in S S S ? Depends on what assumptions you make. In full generality, even only allowing Watson-Crick base pairs, there are O ( n ! ) O(n!) O ( n !) terms in that sum. However, if you assume that there are no crossing pairs, i.e. arcs that would intersect in the above diagram, or pairs ( i , j ) , ( k , l ) (i,j), (k,l) ( i , j ) , ( k , l ) such that i < k i < k i < k , k < j k < j k < j , and j < l j < l j < l , there are only O ( 1. 8 n ) O(1.8&#94;n) O ( 1. 8 n ) terms in the sum. This is still an exponential quantity, but it turns out it is actually computable in sub-exponential time via dynamic programming. This assumption is called the no-pseudoknot assumption, and it means that if I have an ( i , j ) (i,j) ( i , j ) pair, then for all bases in-between them, I can ignore all the bases outside of them when enumerating structures. This begs the question whether it is a physically valid assumption. The answer is NO. There are many RNAs found in nature that have \"crossing\" pairs such as Group I and Group II introns. However, without this assumption, computing the partition function is intractable, so most RNA folding software packages make it. While it is tempting to do analysis on a structure with the minimum free energy and highest probability, since RNA is a thermal system with an exponential multiplicity of states even the probability of the most probable state is extremely low and any quantity computed on even the most probable state has negligible contribution to the physical expected value of that quantity. However, I will show here that not only can we compute the partition function, but we can also sample from the Boltzmann distribution. Once we are able to do that we can compute arbitrary expected values on the full Boltzmann distribution via Monte Carlo integration. (In fact, Monte Carlo integration is not even needed if you can express your quantity in terms of the partition function values, which can give you full expected values without statistical error! But that is outside of the scope of this post). Putting this all together, to predict the folding and general properties of RNA we need 4 things: a specification of a state of RNA s s s , an energy function E ( s ) : S → Energy E(s): S \\to \\text{Energy} E ( s ) : S → Energy , which takes a state and outputs a physical energy, the partition function, the sum of the Boltzmann factors over every possible state Z = ∑ s ′ ∈ S e − E ( s ′ ) / k T Z = \\sum_{s' \\in S} e&#94;{-E(s')/kT} Z = ∑ s ′ ∈ S ​ e − E ( s ′ ) / k T , and an algorithm for sampling structures from the Boltzmann distribution, P ( s ) = e − E ( s ) / k T / Z P(s) = e&#94;{-E(s)/kT}/Z P ( s ) = e − E ( s ) / k T / Z Quick Code Note All code going forward will be in Haskell. You should be able to extract all the code here into a file and it should compile. To set up our environment, make sure to have this header at the top of the file: {-# LANGUAGE NoMonomorphismRestriction #-} {-# LANGUAGE FlexibleContexts #-} {-# LANGUAGE TypeFamilies #-} import Data.Array import Data.Time.Clock.POSIX import Data.Colour import System.Random import Data.List import Diagrams.Prelude import Diagrams.Backend.SVG.CmdLine States of RNA Because of the no-pseudoknot assumption, we can actually specify the states using a recursive data structure. data Structure = Paired Char Char ( Structure , Structure ) | Slip Char Structure | None deriving Show The thought behind this definition is that we are specifying the structure base by base. If base i i i is unpaired, then we move on to the next base. If base i i i is paired, then we fork the structure into the bases underneath the pair and the bases after the pair. We carry along the letter of the base for convenience and to compute the energies of any pairing that might happen. Energy Model A fully realistic energy model of RNA would be very difficult to compute. There are exposed ions everywhere on the strand which interact with each other and there is tension in the backbone. Many of these interactions are non-linear which breaks the recursion and therefore computability of the problem. In practice, there are several levels of complexity that are implemented which try to account for the non-linearities in a computable fashion (this actually is the only difference between professional RNA secondary structure prediction and an Algorithms homework problem). Here I will implement a very simple energy model: adding the free energies of each hydrogen bond. A hydrogen bond contributes about − 6 kJ / mol = − 2.3 k B T -6\\ \\text{kJ}/\\text{mol} = -2.3\\ k_BT − 6 kJ / mol = − 2.3 k B ​ T . Adenine-uracil bonds have 2 hydrogen bonds, guanine-cytosine bonds have 3. Therefore in the exponent of the Boltzmann factor, I will put -4.6 for A-U bonds and -6.9 for G-C bonds. Anything else is represented by infinite energy, meaning that it will never happen. baseEnergy :: Char -> Char -> Double baseEnergy a b = case ( a , b ) of ( 'A' , 'U' ) -> - 4.6 ( 'G' , 'C' ) -> - 6.9 ( 'U' , 'A' ) -> - 4.6 ( 'C' , 'G' ) -> - 6.9 otherwise -> 1.0 / 0.0 -- non-allowed pairs treated like an infinite hill energyModel :: Structure -> Double energyModel ( Paired a b ( s1 , s2 )) = ( baseEnergy a b ) + -- energy of pair ( energyModel s1 ) + -- energy of substructure under pair ( energyModel s2 ) -- energy of substructure after pair energyModel ( Slip _ s ) = energyModel s energyModel None = 0 Partition Function The sum Z = ∑ s ′ ∈ S e − E ( s ′ ) / k T Z = \\sum_{s' \\in S} e&#94;{-E(s')/kT} Z = ∑ s ′ ∈ S ​ e − E ( s ′ ) / k T initially seems daunting. However, from the recursive definition of our energy model, we can easily see that the partition function can be defined recursively as well. To be precise, if we define Z [ i , j ] Z[i,j] Z [ i , j ] as the sub-partition-function from i i i to j j j , it must be equal to the sum of the Boltzmann terms of all structures where i i i is paired and all structures where i i i is unpaired: Z [ i , j ] = Z [ i + 1 , j ] ⏞ i unpaired + ∑ i < k ≤ j B ( i , k ) Z [ i + 1 , k − 1 ] Z [ k + 1 , j ] ⏞ i paired Z[i, j] = \\overbrace{Z[i+1, j]}&#94;{i \\text{ unpaired}} + \\overbrace{\\sum_{i < k \\leq j} B(i, k) Z[i+1, k-1] Z[k+1, j]}&#94;{i \\text{ paired}} Z [ i , j ] = Z [ i + 1 , j ] ​ i unpaired ​ + i < k ≤ j ∑ ​ B ( i , k ) Z [ i + 1 , k − 1 ] Z [ k + 1 , j ] ​ i paired ​ where B ( i , k ) = exp ( − BaseEnergy ( i , k ) ) B(i, k) = \\text{exp}(-\\text{BaseEnergy}(i,k)) B ( i , k ) = exp ( − BaseEnergy ( i , k )) . This becomes a standard dynamic programming problem. We can turn Z into a table of values with O ( n 2 ) O(n&#94;2) O ( n 2 ) cells. If cell ( 0 , 0 ) (0,0) ( 0 , 0 ) is on the bottom left, and ( n − 1 , n − 1 ) (n-1,n-1) ( n − 1 , n − 1 ) on the top right, each row of the table only depends on the entries below and to the left. We can compute the full partition function by starting from the bottom left and working out to the top right in O ( n 3 ) O(n&#94;3) O ( n 3 ) time. This is even parallelizable along the diagonals (I'm not going to parallelize it here). type PFunArray = Array ( Int , Int ) Double boltz :: Double -> Double boltz x = exp ( - x ) partitionFunction :: String -> PFunArray partitionFunction strand = arr where len = length strand arr = array (( 0 , 0 ), ( len - 1 , len - 1 )) [(( i , j ), ( pfCell i j strand arr )) | i <- [ 0 .. len - 1 ], j <- [ i .. len - 1 ]] pfCell :: Int -> Int -> String -> PFunArray -> Double pfCell i j strand arr = if ( i == j ) then 1 else ( sum pairTerms ) + slipTerm where pairTerm i k = boltz ( baseEnergy ( strand !! i ) ( strand !! k )) * ( if k - i > 2 then arr ! ( i + 1 , k - 1 ) else 1 ) * ( if j - k > 1 then arr ! ( k + 1 , j ) else 1 ) pairTerms = [ pairTerm i k | k <- [( i + 1 ) .. j ]] slipTerm = if i == j then 1 else arr ! ( i + 1 , j ) Sampling RNA Structures To actually predict the structure of RNA molecules in nature, we can work backward through the partition function table to sample structures from the Boltzmann distribution. Consider the length of the strand along base i i i to base j j j , the probability that i i i is unpaired is equal to the sum of the probabilities of every structure along i i i to j j j with i i i unpaired, or Z [ i + 1 , j ] Z [ i , j ] \\frac{Z[i+1, j]}{Z[i,j]} Z [ i , j ] Z [ i + 1 , j ] ​ , the probability that i i i is paired to base k k k is equal to the sum of the probabilities of every structure along i i i to j j j where i i i and k k k are paired, or B ( i , k ) Z [ i + 1 , k − 1 ] Z [ k + 1 , j ] Z [ i , j ] \\frac{B(i,k)Z[i+1,k-1]Z[k+1,j]}{Z[i, j]} Z [ i , j ] B ( i , k ) Z [ i + 1 , k − 1 ] Z [ k + 1 , j ] ​ , completing the rest of the structure can be achieved by calling the sampling function recursively for every length of the strand left general, i + 1 i+1 i + 1 to j j j for the unpaired case, i + 1 i+1 i + 1 to k − 1 k-1 k − 1 and k + 1 k+1 k + 1 to j j j for the second case. I encode this logic in Haskell below. At each level I roll a random number from 0 to Z [ i , j ] Z[i,j] Z [ i , j ] and sort through the cases. When I pass cumulative probability greater than the number I've rolled I choose that case and recurse. sampleStructure :: Int -> Int -> PFunArray -> String -> StdGen -> Structure sampleStructure i j arr strand gen = if ( i > j ) then None else struct where -- setup pair terms pairTerm i k = boltz ( baseEnergy ( strand !! i ) ( strand !! k )) * ( if k - i > 2 then arr ! ( i + 1 , k - 1 ) else 1 ) * ( if j - k > 1 then arr ! ( k + 1 , j ) else 1 ) pairTerms = [ pairTerm i k | k <- [( i + 1 ) .. j ]] -- structure functions slipStructure genr = Slip ( strand !! i ) ( sampleStructure ( i + 1 ) j arr strand genr ) innerPairStructure k genr = if k - i > 1 then sampleStructure ( i + 1 ) ( k - 1 ) arr strand genr else None outerPairStructure k genr = if j - k > 0 then sampleStructure ( k + 1 ) ( j ) arr strand genr else None pairStructure k genr = Paired ( strand !! i ) ( strand !! k ) ( innerPairStructure k genr , outerPairStructure k genr ) -- (cumulative probability, structure) pairs slipCase = ( 0 , slipStructure ) -- starting at offset of 0 pairCases = [( sum ( take ( k - i - 1 ) pairTerms ) + arr ! ( i + 1 , j ), pairStructure k ) | k <- [( i + 1 ) .. j ]] allCases = slipCase : pairCases -- sample a random number according to the current sub ( roll , newgen ) = randomR ( 0 , arr ! ( i , j )) gen -- if roll >= cumulative probability switch canidates, else not checkCase current candidate = if roll >= ( fst candidate ) then ( snd candidate ) newgen else current struct = foldl' checkCase None allCases Drawing Structures One last thing to do is to draw these structures, which I do using Brent Yorgey ‘s cool diagrams library. Every base is a circle with a letter underneath, color coded by base, with backbone and arcs denoting bonds. This depicts RNA with the bonds fanned out and visible, whereas other depictions of RNA will try to keep the length of each bond pretty constant, which is a more physical picture. colorMap a = case a of 'G' -> sRGB24read \"#107896\" 'C' -> sRGB24read \"#829356\" 'U' -> sRGB24read \"#F26D21\" 'A' -> sRGB24read \"#C02F1D\" otherwise -> white base :: Char -> Diagram B base b = circle 1 # fc ( colorMap b ) <> text [ b ] # fontSize ( local 2 ) # ( translateY ( - 2.6 )) backbone = hrule 1 isNone :: Structure -> Bool isNone s = case s of None -> True otherwise -> False structLength :: Structure -> Int structLength None = 0 structLength ( Slip _ s ) = 1 + structLength s structLength ( Paired _ _ ( s1 , s2 )) = 2 + structLength s1 + structLength s2 renderStructure :: Structure -> Diagram B renderStructure ( Paired a b ( s1 , s2 )) = base a <> translateX 1.5 backbone <> translateX 3 innerElement <> translateX ( 3.0 * k' ) ( base b ) <> translateX ( 3.0 * k' + 3 ) outerElement <> arc xDir ( 0.5 @@ turn ) # scale ( 1.5 * k' ) # translateX ( 1.5 * k' ) where k = structLength s1 + 1 k' = fromIntegral k innerElement = if isNone s1 then mempty else renderStructure s1 ||| backbone outerElement = if isNone s2 then mempty else translateX ( - 1.5 ) backbone <> renderStructure s2 renderStructure ( Slip c s ) = if isNone s then base c else base c <> translateX 1.5 backbone <> translateX 3 ( renderStructure s ) renderStructure None = mempty Example Output Let's try it out: main = do let gen = mkStdGen 42 let rna = \"GAAAAAAGGGGAAACCAAAGCCCAAUUUGCUUUUAAAAGGCCAA\" let pf = partitionFunction rna let struct = sampleStructure 0 ( length rna - 1 ) pf rna gen let diagram = renderStructure struct mainWith diagram In shell: ghc RNAfolding.hs RNAfolding.o -o RNAt.svg -w 600 -h 300 Cool! Further Reading There is a long history of this problem being solved going back to the 1980's even before John McCaskill first formulated a partition function approach to RNA secondary structure prediction. Below are a couple significant papers in this series, or at least those that are known to me. I'll also put my undergraduate thesis here, where I wrote extensively on a slightly more complicated version of this problem. Partition Functions: McCaskill, J.S., 1990. The equilibrium partition function and base pair binding probabilities for RNA secondary structure. Biopolymers, 29(6‐7), pp.1105-1119. pdf Stochastic Sampling: Ding, Y. and Lawrence, C.E., 2003. A statistical sampling algorithm for RNA secondary structure prediction. Nucleic acids research, 31(24), pp.7280-7301. pdf More complicated energy models: Mathews, D.H., Sabina, J., Zuker, M. and Turner, D.H., 1999. Expanded sequence dependence of thermodynamic parameters improves prediction of RNA secondary structure. Journal of molecular biology, 288(5), pp.911-940. pdf Mathews, D.H., Disney, M.D., Childs, J.L., Schroeder, S.J., Zuker, M. and Turner, D.H., 2004. Incorporating chemical modification constraints into a dynamic programming algorithm for prediction of RNA secondary structure. Proceedings of the National Academy of Sciences of the United States of America, 101(19), pp.7287-7292. pdf Some clear formulations, useful to me: Dirks, R.M. and Pierce, N.A., 2003. A partition function algorithm for nucleic acid secondary structure including pseudoknots. Journal of computational chemistry, 24(13), pp.1664-1677. pdf RNAbows: Aalberts, D.P. and Jannen, W.K., 2013. Visualizing RNA base-pairing probabilities with RNAbow diagrams. RNA, 19(4), pp.475-478. pdf My thesis: Flynn, M.J. and Aalberts, D.P., 2015. RNA Macrostates and Computational Tools. Williams College. github pdf 4 Comments wrmsr January 10, 2017 at 4:13 am Awesome article, in all of content, intersectionality, and presentaion. Have a possible slight correction though that made me stop and double-check: The sum Z = ∑ _ s ' ∈ S e − E ( s ) / k T Z = \\sum\\_{s' \\in S} e&#94;{-E(s)/kT} Z = ∑ _ s ' ∈ S e − E ( s ) / k T initially seems daunting. Shouldn't this be: The sum Z = ∑ _ s ' ∈ S e − E ( s ' ) / k T Z = \\sum\\_{s' \\in S} e&#94;{-E(s')/kT} Z = ∑ _ s ' ∈ S e − E ( s ' ) / k T initially seems daunting. Still processing the rest :p mflynn January 10, 2017 at 4:24 am Yes! Thanks. Brent Yorgey January 10, 2017 at 9:49 pm Hey, this is really cool. I think I remember you trying to explain some of this to me a couple years ago, though I'm not sure I really got it at the time (it makes a lot of sense now, though). Also, nice pictures! 😉 mflynn January 11, 2017 at 4:57 am Thanks! Glad you thought it was cool. Diagrams is very useful!","tags":"misc","url":"https://michaeljflynn.net/simple-rna-folding-in-130-lines-of-haskell.html","loc":"https://michaeljflynn.net/simple-rna-folding-in-130-lines-of-haskell.html"},{"title":"My Favorite Algorithm: Metropolis-Hastings","text":"Note: imported from an earlier version of this blog. Sorry if anything is broken. I'm writing this post because I feel like any computational scientist should have a favorite algorithm, and in my research I have run into this particular algorithm again and again and every time it impresses me. I am also writing this because I googled \"What is your favorite algorithm\" and was surprised to find that no one mentioned it in the top results. Few algorithms in computational physics have the scope and power of the Metropolis-Hastings algorithm. Briefly, given a domain D \\mathcal D D and a function with bounded integral over that domain f ( x ) f(\\mathbf x) f ( x ) , the MH-algorithm samples n n n points from a probability distribution proportional to f ( x ) f(\\mathbf x) f ( x ) . This subtle technique can solve very difficult problems in the design of engines, rockets, generators, nuclear weapons and reactors, plasma physics, the simulation of thermodynamic systems and transport of light in Computer Graphics, the computation of partition functions of RNA macrostates and their transition states, and the computation of posterior distributions in Bayesian statistics (as well as a family of statistical tools that I know relatively less about). In this post I plan to describe the algorithm, Monte Carlo integration, and some examples of applications. The Algorithm Let's say we have some function f ( x ) f(\\mathbf x) f ( x ) over some domain D \\mathcal D D such that ∫ D f ( x ) d x = C . \\int_{\\mathcal D} f(\\mathbf x) d\\mathbf x = C . ∫ D ​ f ( x ) d x = C . For example f ( x ) f(x) f ( x ) could be e − x 2 e&#94;{-x&#94;2} e − x 2 and D \\mathcal D D could be the real line [ − ∞ , ∞ ] [-\\infty, \\infty] [ − ∞ , ∞ ] , or the uniform distribution U ( x ) = 1 U(x)=1 U ( x ) = 1 and the interval [ 0 , 1 ] [0,1] [ 0 , 1 ] : ∫ − ∞ ∞ e − x 2 d x = π , \\int_{-\\infty}&#94;\\infty e&#94;{-x&#94;2} dx = \\sqrt{\\pi}, ∫ − ∞ ∞ ​ e − x 2 d x = π ​ , = ∫ 0 1 d x = 1 , \\int_0&#94;1 dx = 1, ∫ 0 1 ​ d x = 1 , or some higher dimensional function with a corresponding higher dimensional domain. It turns out we can generate a list of samples from the probability distribution p p p proportional to this function, p ( x ) = 1 C f ( x ) , p(\\mathbf x) = \\frac{1}{C}\\ f(\\mathbf x), p ( x ) = C 1 ​ f ( x ) , (for our examples C = π C = \\sqrt{\\pi} C = π ​ and 1 1 1 , respectively) by following a simple procedure: Start at some initial state x 0 \\mathbf x_0 x 0 ​ and generate the output, a list of samples x 0 , x 1 , … , x n \\mathbf x_0, \\mathbf x_1, \\dots, \\mathbf x_n x 0 ​ , x 1 ​ , … , x n ​ , by continuously sampling x n + 1 \\mathbf x_{n+1} x n + 1 ​ from some probability distribution function (that you choose) set by x n \\mathbf x_n x n ​ : P t ( x n , x n + 1 ) . P_t(\\mathbf x_n, \\mathbf x_{n+1}). P t ​ ( x n ​ , x n + 1 ​ ) . This list of samples will converge to p ( x ) p(\\mathbf x) p ( x ) provided some conditions on P t ( x n , x n + 1 ) P_t(\\mathbf x_n, \\mathbf x_{n+1}) P t ​ ( x n ​ , x n + 1 ​ ) are satisfied, namely ergodicity, which means that every state can eventually reach any other state, and detailed balance. If there are N ( x ) N(\\mathbf x) N ( x ) samples in state x \\mathbf x x at some point in the chain, the number of samples in state y \\mathbf y y created by transitions from these states is expected to be N ( x ) P t ( x , y ) N(\\mathbf x)P_t(\\mathbf x, \\mathbf y) N ( x ) P t ​ ( x , y ) . N ( x ) P t ( x , y ) − N ( y ) P t ( y , x ) N(\\mathbf x) P_t(\\mathbf x,\\mathbf y) - N(\\mathbf y) P_t(\\mathbf y, \\mathbf x) N ( x ) P t ​ ( x , y ) − N ( y ) P t ​ ( y , x ) is called the transition rate from x \\mathbf x x to y \\mathbf y y because it is the expected flow of states from x \\mathbf x x to y \\mathbf y y (or the other way, if it is negative). Detailed balance is said to hold if the transition rates between all states are zero when the sample has reached the correct probability distribution. This way the net flow of probability is zero and the distribution is expected to stay the same. Therefore if we have sampled N T N_T N T ​ states and we want to reach distribution p ( x ) p(\\mathbf x) p ( x ) , if we have that N ( x ) = N T p ( x ) N(\\mathbf x) = N_T p(\\mathbf x) N ( x ) = N T ​ p ( x ) and want N ( x ) P t ( x , y ) = N ( y ) P t ( y , x ) N(\\mathbf x) P_t(\\mathbf x, \\mathbf y) = N(\\mathbf y) P_t(\\mathbf y, \\mathbf x) N ( x ) P t ​ ( x , y ) = N ( y ) P t ​ ( y , x ) , our transition probabilities P t P_t P t ​ should be constrained by: p ( x n ) P t ( x n , x n + 1 ) = p ( x n + 1 ) P t ( x n + 1 , x n ) . p(\\mathbf x_n) P_t(\\mathbf x_n, \\mathbf x_{n+1}) = p(\\mathbf x_{n+1}) P_t(\\mathbf x_{n+1},\\mathbf x_n). p ( x n ​ ) P t ​ ( x n ​ , x n + 1 ​ ) = p ( x n + 1 ​ ) P t ​ ( x n + 1 ​ , x n ​ ) . From here we can break P t ( x 1 , x 2 ) P_t(\\mathbf x_1,\\mathbf x_2) P t ​ ( x 1 ​ , x 2 ​ ) down into the product of 2 different distributions, T ( x 1 , x 2 ) T(\\mathbf x_1, \\mathbf x_2) T ( x 1 ​ , x 2 ​ ) , the probability of generating a transition from x 1 \\mathbf x_1 x 1 ​ to x 2 \\mathbf x_2 x 2 ​ , and A ( x 1 , x 2 ) A(\\mathbf x_1, \\mathbf x_2) A ( x 1 ​ , x 2 ​ ) , the probability of accepting that transition. We do this to let the definition of T T T be flexible by having A A A handle the constraint. This is done by solving for A A A with a general T T T : p ( x 1 ) P t ( x 1 , x 2 ) = p ( x 2 ) P t ( x 2 , x 1 ) p(\\mathbf x_1) P_t(\\mathbf x_1, \\mathbf x_2) = p(\\mathbf x_2) P_t(\\mathbf x_2,\\mathbf x_1) p ( x 1 ​ ) P t ​ ( x 1 ​ , x 2 ​ ) = p ( x 2 ​ ) P t ​ ( x 2 ​ , x 1 ​ ) p ( x 1 ) T ( x 1 , x 2 ) A ( x 1 , x 2 ) = p ( x 2 ) T ( x 2 , x 1 ) A ( x 2 , x 1 ) p(\\mathbf x_1) T(\\mathbf x_1,\\mathbf x_2) A(\\mathbf x_1,\\mathbf x_2) = p(\\mathbf x_2) T(\\mathbf x_2, \\mathbf x_1) A(\\mathbf x_2, \\mathbf x_1) p ( x 1 ​ ) T ( x 1 ​ , x 2 ​ ) A ( x 1 ​ , x 2 ​ ) = p ( x 2 ​ ) T ( x 2 ​ , x 1 ​ ) A ( x 2 ​ , x 1 ​ ) A ( x 1 , x 2 ) A ( x 2 , x 1 ) = p ( x 2 ) T ( x 2 , x 1 ) p ( x 1 ) T ( x 1 , x 2 ) = f ( x 2 ) T ( x 2 , x 1 ) f ( x 1 ) T ( x 1 , x 2 ) \\frac{A(\\mathbf x_1,\\mathbf x_2)}{A(\\mathbf x_2,\\mathbf x_1)} = \\frac{p(\\mathbf x_2) T(\\mathbf x_2,\\mathbf x_1)}{p(\\mathbf x_1) T(\\mathbf x_1,\\mathbf x_2) } = \\frac{f(\\mathbf x_2) T(\\mathbf x_2,\\mathbf x_1)}{f(\\mathbf x_1) T(\\mathbf x_1,\\mathbf x_2) } A ( x 2 ​ , x 1 ​ ) A ( x 1 ​ , x 2 ​ ) ​ = p ( x 1 ​ ) T ( x 1 ​ , x 2 ​ ) p ( x 2 ​ ) T ( x 2 ​ , x 1 ​ ) ​ = f ( x 1 ​ ) T ( x 1 ​ , x 2 ​ ) f ( x 2 ​ ) T ( x 2 ​ , x 1 ​ ) ​ One choice that satisfies this equation is A ( x 1 , x 2 ) = min ⁡ { f ( x 2 ) T ( x 2 , x 1 ) f ( x 1 ) T ( x 1 , x 2 ) , 1 } . A(\\mathbf x_1,\\mathbf x_2) = \\min \\left \\{ \\frac{f(\\mathbf x_2) T(\\mathbf x_2,\\mathbf x_1) }{f(\\mathbf x_1) T(\\mathbf x_1,\\mathbf x_2) }, 1 \\right \\}. A ( x 1 ​ , x 2 ​ ) = min { f ( x 1 ​ ) T ( x 1 ​ , x 2 ​ ) f ( x 2 ​ ) T ( x 2 ​ , x 1 ​ ) ​ , 1 } . Provided that the function A A A satisfies these constraints, we can construct a mutation function that samples from T T T to give us a new element, create the chain by accepting or rejecting the new element, and the samples' distribution will converge to p ( x ) p(\\mathbf x) p ( x ) . Example Let's say we want to sample from a difficult distribution on the ( x , y ) (x,y) ( x , y ) -plane, perhaps the one proportional to f ( x , y ) = sin ⁡ 2 ( r ) r 3 = sin ⁡ 2 ( x 2 + y 2 ) ( x 2 + y 2 ) 3 / 2 . f(x,y) = \\frac{\\sin&#94;2(r)}{r&#94;3} = \\frac{\\sin&#94;2(\\sqrt{x&#94;2 + y&#94;2})}{(x&#94;2+y&#94;2)&#94;{3/2}}. f ( x , y ) = r 3 sin 2 ( r ) ​ = ( x 2 + y 2 ) 3/2 sin 2 ( x 2 + y 2 ​ ) ​ . Since this distribution is pretty difficult to sample directly, instead we use Metropolis-Hastings. Let's construct a mutation function that chooses from all directions uniformly and moves in that direction a distance d d d with probability p d ( d ) = e − d p_d(d) = e&#94;{-d} p d ​ ( d ) = e − d . Our acceptance probability should therefore be: A ( x 1 , x 2 ) = min ⁡ { f ( x 2 ) e − d / 2 π f ( x 1 ) e − d / 2 π , 1 } = min ⁡ { sin ⁡ 2 ( x 2 2 + y 2 2 ) ( x 1 2 + y 1 2 ) 3 / 2 sin ⁡ 2 ( x 1 2 + y 1 2 ) ( x 2 2 + y 2 2 ) 3 / 2 , 1 } A(\\mathbf x_1, \\mathbf x_2) = \\min \\left \\{ \\frac{f(\\mathbf x_2) e&#94;{-d}/2\\pi }{f(\\mathbf x_1) e&#94;{-d}/2\\pi }, 1 \\right \\} = \\min \\left \\{ \\frac{\\sin&#94;2(\\sqrt{x_2&#94;2 + y_2&#94;2}) (x_1&#94;2 + y_1&#94;2)&#94;{3/2}}{\\sin&#94;2(\\sqrt{x_1&#94;2 + y_1&#94;2}) (x_2&#94;2 + y_2&#94;2)&#94;{3/2} }, 1 \\right \\} A ( x 1 ​ , x 2 ​ ) = min { f ( x 1 ​ ) e − d /2 π f ( x 2 ​ ) e − d /2 π ​ , 1 } = min { sin 2 ( x 1 2 ​ + y 1 2 ​ ​ ) ( x 2 2 ​ + y 2 2 ​ ) 3/2 sin 2 ( x 2 2 ​ + y 2 2 ​ ​ ) ( x 1 2 ​ + y 1 2 ​ ) 3/2 ​ , 1 } This is all we need to know to implement a sampling algorithm in R: ## Metropolis Hastings demonstration by Mike Flynn ## Warning: This code has a runtime of around 4 hours on my machine samples = matrix ( nrow = 10 &#94; 6 , ncol = 2 ) currentSample = c ( 0.001 , 0.001 ) set.seed ( 44 ) for ( i in 1 : ( 10 &#94; 8 )) { ## choose direction and distance for transition direction = runif ( 1 , 0 , 2 * pi ) distance = rexp ( 1 , 2 ) ## current point x1 = currentSample [ 1 ] y1 = currentSample [ 2 ] ## compute next point x2 = x1 + distance * cos ( direction ) y2 = y1 + distance * sin ( direction ) ## accept? accept = min ( sin ( sqrt ( x2 &#94; 2 + y2 &#94; 2 )) &#94; 2 * ( x1 &#94; 2 + y1 &#94; 2 ) &#94; ( 3 / 2 ) / ( sin ( sqrt ( x1 &#94; 2 + y1 &#94; 2 )) &#94; 2 * ( x2 &#94; 2 + y2 &#94; 2 ) &#94; ( 3 / 2 )), 1 ) if ( accept > runif ( 1 , 0 , 1 )) { currentSample = c ( x2 , y2 ) } else { currentSample = c ( x1 , y1 ) } ## only take 1 of every 100 to reduce autocorrelation if ( i %% 100 == 0 ) { samples [ i / 100 ,] = currentSample } } library ( ggplot2 ) library ( ggthemes ) plotdat = data.frame ( x = samples [, 1 ], y = samples [, 2 ]) ## display p to plot p = ggplot ( data = plotdat , aes ( x = x , y = y )) + geom_point ( alpha = . 05 , size = . 01 ) + theme_bw () + xlim ( -6 * pi , 6 * pi ) + ylim ( -6 * pi , 6 * pi ) which outputs this picture: This plot looks a lot like interference fringes to me, which pleases me as a physicist. Of course, this example is completely contrived: interference fringes sometimes roughly follow this distribution. More importantly, the samples produced by the Metropolis-Hastings algorithm do seem to match the probability distribution proportional to sin ⁡ 2 ( r ) / r 3 \\sin&#94;2(r)/r&#94;3 sin 2 ( r ) / r 3 . Monte Carlo Integration and Importance Sampling Monte Carlo integration is the process of evaluating an integral by sampling randomly from the domain and averaging. Often Monte Carlo integration of f ( x ) f(\\mathbf x) f ( x ) will make use of the expectation value identity for n n n samples, x i \\mathbf x_i x i ​ , from a probability distribution p ( x ) p(\\mathbf x) p ( x ) on the same domain 1 n ∑ i = 1 n f ( x i ) p ( x i ) → converges to E [ f ( x ) p ( x ) ] = ∫ D f ( x ) p ( x ) p ( x ) d x = ∫ D f ( x ) d x . \\frac{1}{n} \\sum_{i=1}&#94;n \\frac{f(\\mathbf x_i)}{p(\\mathbf x_i)} \\xrightarrow[]{\\text{converges to}} E\\left [ \\frac{f(\\mathbf x)}{p(\\mathbf x)} \\right ] = \\int_{\\mathcal D} \\frac{f(\\mathbf x)}{p(\\mathbf x)} p(\\mathbf x) d\\mathbf x = \\int_{\\mathcal D} f(\\mathbf x) d\\mathbf x. n 1 ​ i = 1 ∑ n ​ p ( x i ​ ) f ( x i ​ ) ​ converges to ​ E [ p ( x ) f ( x ) ​ ] = ∫ D ​ p ( x ) f ( x ) ​ p ( x ) d x = ∫ D ​ f ( x ) d x . For example we might evaluate the integral ∫ 1 3 e − x d x \\int_1&#94;3 e&#94;{-x}dx ∫ 1 3 ​ e − x d x by randomly sampling x i x_i x i ​ from the uniform density on [ 1 , 3 ] [1,3] [ 1 , 3 ] , letting f ( x ) = e − x f(x) = e&#94;{-x} f ( x ) = e − x , p ( x ) = 1 / ( 3 − 1 ) p(x) = 1/(3-1) p ( x ) = 1/ ( 3 − 1 ) , and averaging: 1 n ∑ i = 1 n e − x i 1 / ( 3 − 1 ) → converges to ∫ 1 3 e − x 1 / ( 3 − 1 ) 1 / ( 3 − 1 ) d x = ∫ 1 3 e − x d x . \\frac{1}{n} \\sum_{i=1}&#94;n \\frac{e&#94;{-x_i}}{1/(3-1)} \\xrightarrow[]{\\text{converges to}} \\int_1&#94;3 \\frac{e&#94;{-x}}{1/(3-1)}1/(3-1) dx = \\int_1&#94;3 e&#94;{-x} dx . n 1 ​ i = 1 ∑ n ​ 1/ ( 3 − 1 ) e − x i ​ ​ converges to ​ ∫ 1 3 ​ 1/ ( 3 − 1 ) e − x ​ 1/ ( 3 − 1 ) d x = ∫ 1 3 ​ e − x d x . The closer p ( x ) p(\\mathbf x) p ( x ) gets to the shape of the integrated function, the faster the convergence will be. For example, if p ( x ) = f ( x ) / N p(\\mathbf x) = f(\\mathbf x)/N p ( x ) = f ( x ) / N , then the above derivation will yield ∫ D f ( x ) d x ≈ 1 n ∑ i = 1 n f ( x ) f ( x ) / N = n N n = N . \\int_{\\mathcal D} f(\\mathbf x) d\\mathbf x \\approx \\frac{1}{n} \\sum_{i=1}&#94;n \\frac{f(\\mathbf x)}{f(\\mathbf x)/N} = \\frac{nN}{n} = N. ∫ D ​ f ( x ) d x ≈ n 1 ​ i = 1 ∑ n ​ f ( x ) / N f ( x ) ​ = n n N ​ = N . No matter what n n n is, it will converge after the first iteration. This is cheating because it assumes we already know the answer, N N N . In general we won't have access to this knowledge, or else we wouldn't be doing the integral in the first place. However, we do have the Metropolis-Hastings algorithm to let us sample from f ( x ) / N f(\\mathbf x)/N f ( x ) / N without explicitly knowing N N N . We can use this in many creative ways, stemming from the fact that the expectation value of any statistic g g g on these samples is 1 N ∫ g ( x ) f ( x ) d x \\frac{1}{N} \\int g(\\mathbf x) f(\\mathbf x) d\\mathbf x N 1 ​ ∫ g ( x ) f ( x ) d x . Integrating the Example Luckily enough our example function can be integrated over the entire x-y plane by hand: ∫ 0 2 π ∫ 0 ∞ ( sin ⁡ 2 ( r ) r 3 ) r d r d θ = 2 π ∫ 0 ∞ sin ⁡ 2 ( r ) r 2 d r = 2 π ∗ π 2 = π 2 . \\int_0&#94;{2\\pi} \\int_0&#94;\\infty \\left ( \\frac{\\sin&#94;2(r)}{r&#94;3} \\right ) r dr d\\theta = 2\\pi \\int_0&#94;\\infty \\frac{\\sin&#94;2(r)}{r&#94;2} dr = 2\\pi * \\frac{\\pi}{2} = \\pi&#94;2. ∫ 0 2 π ​ ∫ 0 ∞ ​ ( r 3 sin 2 ( r ) ​ ) r d r d θ = 2 π ∫ 0 ∞ ​ r 2 sin 2 ( r ) ​ d r = 2 π ∗ 2 π ​ = π 2 . (The r r r integral can be done via some complex analysis ). Does our Metropolis-Hastings result corroborate this? Consider a function f ( x ) f(\\mathbf x) f ( x ) and the results of the MH-algorithm on that function, n n n samples from the distribution p ( x ) = f ( x ) / N p(\\mathbf x) = f(\\mathbf x)/N p ( x ) = f ( x ) / N . We are looking for N N N . Let's say we come up with some function U ( x ) U(\\mathbf x) U ( x ) and take the following statistic: 1 n ∑ i = 1 n U ( x i ) f ( x i ) ≈ E [ U ( x ) f ( x ) ] = ∫ D U ( x ) f ( x ) p ( x ) d x = 1 N ∫ D U ( x ) d x . \\frac{1}{n} \\sum_{i=1}&#94;n \\frac{U(\\mathbf x_i)}{f(\\mathbf x_i)} \\approx E \\left [ \\frac{U(\\mathbf x)}{f(\\mathbf x)} \\right ] = \\int_{\\mathcal D} \\frac{U(\\mathbf x)}{f(\\mathbf x)} p(\\mathbf x)d\\mathbf x = \\frac{1}{N} \\int_{\\mathcal D} U(\\mathbf x) d\\mathbf x. n 1 ​ i = 1 ∑ n ​ f ( x i ​ ) U ( x i ​ ) ​ ≈ E [ f ( x ) U ( x ) ​ ] = ∫ D ​ f ( x ) U ( x ) ​ p ( x ) d x = N 1 ​ ∫ D ​ U ( x ) d x . As long as U ( x ) U(\\mathbf x) U ( x ) integrates to 1 1 1 over the domain, the answer comes out to be 1 / N 1/N 1/ N , so we can just take the reciprocal to get our answer. On the ( x , y ) (x,y) ( x , y ) plane, a good function that integrates to 1 and matches the shape of our function pretty well is U ( r ) = 1 π e − r 2 U(r) = \\frac{1}{\\pi} e&#94;{-r&#94;2} U ( r ) = π 1 ​ e − r 2 , so our statistic becomes: 1 n π ∑ i = 1 n e − r i 2 r i 3 sin ⁡ 2 ( r i ) . \\frac{1}{n\\pi} \\sum_{i=1}&#94;n \\frac{ e&#94;{-r_i&#94;2} r_i&#94;3 }{ \\sin&#94;2(r_i) }. nπ 1 ​ i = 1 ∑ n ​ sin 2 ( r i ​ ) e − r i 2 ​ r i 3 ​ ​ . We hope the answer comes out close to 1 / π 2 ≈ 0.10132 1/\\pi&#94;2 \\approx 0.10132 1/ π 2 ≈ 0.10132 . I compute the statistic with 1 line of R code: estimate = sum ( apply ( samples , 1 , function ( row ) exp ( - row [ 1 ] &#94; 2 - row [ 2 ] &#94; 2 ) * ( row [ 1 ] &#94; 2 + row [ 2 ] &#94; 2 ) &#94; ( 3 / 2 ) / ( sin ( sqrt ( row [ 1 ] &#94; 2 + row [ 2 ] &#94; 2 )) &#94; 2 ) )) / ( nrow ( samples ) * pi ) When running this line on the data generated by the previous code block, I get the answer 0.1016102, less than 1% away from the true value. Taking the square root of the reciprocal I get 3.137121, not a bad estimate of π \\pi π for a seemingly arbitrary sum. Pretty remarkable. Applications The applications of Metropolis-Hastings is truly where the algorithm shines. Many integrals are not solvable in \"closed form\" via the Fundamental Theorem of Calculus because they have no antiderivative that can be expressed in terms of elementary functions (apparently this is provable ) , for example the integral ∫ a b x x d x . \\int_a&#94;b x&#94;x dx. ∫ a b ​ x x d x . For these problems, if you really need to know the solution you can use numerical methods of estimating the integral, such as the trapezoidal rule (bringing back fond memories of AP calculus). For some integrals we cannot even use those techniques. This could be because either there are too many dimensions we are integrating over, which forces us to use exponentially many \"trapezoids\", or it could be that the domain is really large (perhaps infinitely large) and contributions from different parts are uneven. For these problems Monte Carlo integration is the best option. There are many examples of such problems in statistical mechanics. The spread of heat through conduction, convection, and radiation is essential for the design of engines, rockets, and electric generators. The many pathways of heat transfer must be integrated, a large space over which Monte Carlo integration is the only practical option. Neutron transport for the design of nuclear weapons and reactors is another similar problem. A third example would be the transport of light or photons through a scene for the purpose of rendering a physically accurate image in Computer Graphics, for which the application of the MH-algorithm has it's own name: Metropolis Light Transport. To illustrate how the MH-algorithm makes hard integrals solvable, here is the luminosity equation from Computer Graphics: L ( X , ω &#94; 0 ) = L e ( X , ω &#94; 0 ) + ∫ S 2 L i ( X , ω &#94; i ) f X , n &#94; ( ω &#94; i , ω &#94; 0 ) ∣ ω &#94; i ⋅ n &#94; ∣ d ω &#94; i . L(X, \\hat \\omega_0) = L_e(X, \\hat \\omega_0) + \\int_{\\mathcal S&#94;2}L_i(X, \\hat\\omega_i) f_{X,\\hat n}(\\hat \\omega_i, \\hat \\omega_0) |\\hat \\omega_i \\cdot \\hat n | d\\hat\\omega_i. L ( X , ω &#94; 0 ​ ) = L e ​ ( X , ω &#94; 0 ​ ) + ∫ S 2 ​ L i ​ ( X , ω &#94; i ​ ) f X , n &#94; ​ ( ω &#94; i ​ , ω &#94; 0 ​ ) ∣ ω &#94; i ​ ⋅ n &#94; ∣ d ω &#94; i ​ . A quick description: the L L L is the light outgoing from a flat surface X X X in direction ω &#94; 0 \\hat \\omega_0 ω &#94; 0 ​ , L e L_e L e ​ is the light emitted by that surface in that direction, L i ( X , ω &#94; i ) L_i(X, \\hat\\omega_i) L i ​ ( X , ω &#94; i ​ ) is the light incoming to that surface from direction ω &#94; i \\hat \\omega_i ω &#94; i ​ , f X , n &#94; ( ω &#94; i , ω &#94; 0 ) ∣ ω &#94; i ⋅ n &#94; ∣ f_{X, \\hat n}(\\hat \\omega_i, \\hat \\omega_0) | \\hat \\omega_i \\cdot \\hat n | f X , n &#94; ​ ( ω &#94; i ​ , ω &#94; 0 ​ ) ∣ ω &#94; i ​ ⋅ n &#94; ∣ is the chance that light incoming from ω &#94; i \\hat \\omega_i ω &#94; i ​ will scatter in direction ω &#94; 0 \\hat \\omega_0 ω &#94; 0 ​ , and ω &#94; i \\hat \\omega_i ω &#94; i ​ is integrated over the positive hemisphere S 2 \\mathcal S&#94;2 S 2 . In English terms, what this equation is saying is that to find the amount of light that is bouncing off a surface towards you, you have to add up the amount of light being bounced towards that surface from all other surfaces, and find all the light that is being bounced towards them , and so on. This integral is defined recursively! It is actually an infinite recursion of infinite integrals. This qualifies as a very hard integral. Luckily a surface absorbs some of the light bouncing off of it so it converges and we don't go blind, but how do we integrate this? A slick way to do it is to expand the integral into an integral over paths through each pixel instead of a recursive integral. That way we would have that the light received by pixel j j j , m j m_j m j ​ , could be expressed as: m j = ∫ ( Light from paths of length 1 ) d x + ∫ ( Light from paths of length 2 ) d x + … = ∫ Ω w j ( x ) f ( x ) d μ \\begin{align*}m_j &= \\int ( \\text{Light from paths of length } 1) dx \\\\&+ \\int ( \\text{Light from paths of length } 2)dx + \\dots \\\\ & = \\int_\\Omega w_j(\\mathbf x) f(\\mathbf x) d \\mu \\end{align*} m j ​ ​ = ∫ ( Light from paths of length 1 ) d x + ∫ ( Light from paths of length 2 ) d x + … = ∫ Ω ​ w j ​ ( x ) f ( x ) d μ ​ Where Ω \\Omega Ω is the space of all paths of light through the camera, w j ( x ) w_j(\\mathbf x) w j ​ ( x ) is what proportion of light of each color that path contributes to that pixel, f ( x ) f(\\mathbf x) f ( x ) is the total amount of light flowing along that path, and μ \\mu μ is a measure on that path. We can then treat this as a Monte Carlo integration problem, sample n n n paths ( x i \\mathbf x_i x i ​ ) from the distribution p ( x ) = f ( x ) / C p(\\mathbf x) = f(\\mathbf x)/C p ( x ) = f ( x ) / C using the MH-algorithm, and use the expectation value identity: 1 n ∑ i = 1 n w j ( x i ) ≈ E [ w j ( x ) ] = ∫ Ω w j ( x ) p ( x ) d μ = 1 C ∫ Ω w j ( x ) f ( x ) d μ , \\frac{1}{n} \\sum_{i=1}&#94;n w_j(\\mathbf x_i) \\approx E[w_j(\\mathbf x)] = \\int_{\\Omega} w_j(\\mathbf x) p(\\mathbf x) d\\mu = \\frac{1}{C} \\int_\\Omega w_j(\\mathbf x) f(\\mathbf x) d\\mu, n 1 ​ i = 1 ∑ n ​ w j ​ ( x i ​ ) ≈ E [ w j ​ ( x )] = ∫ Ω ​ w j ​ ( x ) p ( x ) d μ = C 1 ​ ∫ Ω ​ w j ​ ( x ) f ( x ) d μ , to get the value of the integral, multiplied by a normalization constant (but this can be quickly found and set to whatever looks good at the end of the process). Because Metropolis Light Transport samples the most important points first, it has the fastest general convergence time of any unbiased Monte Carlo method. Additionally, it is trivially parallelized. The Metropolis-Hastings algorithm makes normally impossible integrals solvable with relative efficiency, and because of the wide range of applications of the algorithm to problems that are very cool I consider it my favorite. References Much of what I have written here is knowledge that I built up over summer research on sampling methods and a Computer Graphics class I took this fall, including the luminosity equation I got from The Graphics Codex by Morgan McGuire, the Metropolis Light Transport paper and Ph. D thesis of Eric Veach. In addition I learned much about Monte Carlo methods from Computer Graphics: Principles and Practice by by John F. Hughes , Andries van Dam , Morgan McGuire , David F. Sklar , James D. Foley , Steven K. Feiner , and Kurt Akeley, which could be considered a holy text. Also important are the papers where the algorithm originates by Metropolis et al and Williams Hastings , and an explanatory article by Chib and Greenberg. Full citations for these are below: Chib, Siddhartha, and Edward Greenberg. \"Understanding the metropolis-hastings algorithm.\" The american statistician 49, no. 4 (1995): 327-335. Hastings, W.K. (1970). \"Monte Carlo Sampling Methods Using Markov Chains and Their Applications\". Biometrika 57 (1): 97–109. Hughes, John F.; van Dam, Andries; McGuire, Morgan; Sklar, David F.; Foley, James D.; Feiner, Steven K.; and Akeley, Kurt. Computer graphics: principles and practice . Pearson Education, 2013. McGuire, Morgan. The Graphics Codex. Online book at www.graphicscodex.com . Metropolis, N.; Rosenbluth, A.W.; Rosenbluth, M.N.; Teller, A.H.; Teller, E. (1953). \"Equations of State Calculations by Fast Computing Machines\". Journal of Chemical Physics 21 (6): 1087–1092. Veach, Eric. \"Robust monte carlo methods for light transport simulation.\" PhD diss., Stanford University, 1997. Veach, Eric, and Leonidas J. Guibas. \"Metropolis light transport.\" In Proceedings of the 24th annual conference on Computer graphics and interactive techniques , pp. 65-76. ACM Press/Addison-Wesley Publishing Co., 1997. 6 Comments David Rachel June 1, 2015 at 2:46 pm Nice article! I'd not heard of Metropolis-Hastings, but it's awesome. Since the limit behaviour is independent of the jump width, does that mean that the transition function T (jump width) can be arbitrarily altered mid-algorithm without undermining the result? If so, is there any potential benefit in this? Something like annealing, or even fancy and adaptive things – e.g. target desired acceptance/rejection rate, or transition function determined by variance (scalar or matrix) of existing selection? Patrick Schnell June 1, 2015 at 4:21 pm Changing the transition function mid-algorithm can affect the asymptotic result if you're not careful. For example, making jumps smaller or when the current position is in a specific region could lead to that region being over-represented. However, there are benefits to tuning the acceptance rate or reducing the autocorrelation of the sampling process, such as reducing the variance of the integral estimate or making sure that you adequately explore all local maxima. To do this without damaging the convergence of the algorithm, one can specify a \"burn-in\" segment at the beginning in which parameters of the algorithm are tuned, and then throw out those samples. This has the added advantage of making the final result less dependent on the starting point. Alex Campbell June 1, 2015 at 5:23 pm Interesting stuff Michael, have you ever encounter stochastic evolutionary game dynamics? It's a way you can take these methods and merge them with some pretty interesting frameworks coming out of game theory. Basically a way to connect the world of analyzing dynamic, stochastic systems to the world of human behavior. Where does the ‘system' end up, when the system is a complex world of players, beliefs, actions, and payoff functions. Link below is a pretty good paper on the topic from my thesis advisors at Oxford. Think you would enjoy it. http://www.econ2.jhu.edu/people/Young/Stochastic_Evolutionary_Game_Dynamics.pdf mflynn June 2, 2015 at 7:02 am Sounds interesting, I'll check that paper out! Dennis Snell June 1, 2015 at 9:53 pm Thanks Michael for the great article. It's such an amazing thing to see when we can take previously unsolvable problems and transform them into nothing more than a tedious calculation. Probability FTW! Kshitij Lauria June 3, 2015 at 8:22 pm @David Rachel If you change transition probabilities mid-algorithm, you must be very careful that you have not made your Markov chain irreversible. An intuitive way to understand detailed balance is that it means your state transitions are reversible: the likelihood of a path is the same in either direction. Simulated annealing makes use of the idea of Metropolis-Hastings by constructing a FAMILY of reversible Markov chains (each temperature). http://www.mit.edu/~dbertsim/papers/Optimization/Simulated%20annealing.pdf is a survey paper.","tags":"misc","url":"https://michaeljflynn.net/my-favorite-algorithm-metropolis-hastings.html","loc":"https://michaeljflynn.net/my-favorite-algorithm-metropolis-hastings.html"}]};